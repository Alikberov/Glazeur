<!doctype html>
<html itemscope='' itemtype='http://schema.org/SearchResultsPage' lang='ru'		  >
<head											  >
<meta content='text/html; charset=windows-1251'		http-equiv='Content-Type'	 />
<meta content='ru-RU'					http-equiv='Content-Language'	 />
<meta content='keyboard,illumination,led,leds,effect,effects,fx,braile'	name='keywords'	 />
<meta content='Static'							name='googlebot' />
<meta content='NoIndex,NoArchive'					name='Robots'	 />
<meta content='http://github.com/Alikberov'				name='Author'	 />
<meta description='Glazeur-Scenarist'							 />
<title>Glazeur-scripting</title>
<style>
a	{
	border		:blue thin outset;
}
pre#leds{
	background-color:grey;
}
td.operator	{
	border		:white thin outset;
	cursor		:pointer;
	font-family	:"Segoe UI Emoji";
	font-size	:28px;
}
td.switch_1	{
	background-color:yellow;
	border		:white thin outset;
	cursor		:pointer;
	font-family	:"Segoe UI Emoji";
	font-size	:28px;
}
td.switch_2	{
	background-color:cyan;
	border		:white thin outset;
	cursor		:pointer;
	font-family	:"Segoe UI Emoji";
	font-size	:28px;
}
td.switch_3	{
	background-color:magenta;
	border		:white thin outset;
	cursor		:pointer;
	font-family	:"Segoe UI Emoji";
	font-size	:28px;
}
textarea{
	font-family	:"Segoe UI Emoji";
	font-size	:18px;
}
</style>
<script>
function	WCHAR(str) {
	var
		ptr	= 0,
		string	= str;
	return {
		set ptr(seek)	{	// seek to position
			ptr = seek;
		},
		set concat(str)	{
			string += str;
		},
		get ptr()	{	// get the position
			return ptr;
		},
		get str()	{	// get string by position
			return string.substr(ptr);
		},
		get c_ptr()	{	// char by pointer
			return string.charAt(ptr);
		},
		get a_ptr()	{	// ascii by pointer
			return string.charCodeAt(ptr);
		},
		get c_ptr_pp()	{	// char by pointer with post-increment
			return string.charAt(ptr ++);
		},
		get a_ptr_pp()	{	// ascii by pointer with post-increment
			return string.charCodeAt(ptr ++);
		},
		get c_pp_ptr()	{	// char by pointer with pre-increment
			return string.charAt(++ ptr);
		},
		get a_pp_ptr()	{	// ascii by pointer with pre-increment
			return string.charCodeAt(++ ptr);
		}
	};
}
////////////////////////////////////////////////////////////////////////////////
var	LEDs	= {
		levels	: [0,0,0,0,0,0,0,0,0,0],
		movie	: [],
		order	: 0,
		speed	: 100,
		iDelay	: 100,
		iKeyboard	: 0,
		tmp	: {
			iNumerator	:0,
			iDenominator	:0,
			pReps		:[],
			nReps		:[],
			dReps		:[]
			},
		Measures: [],
		iMeasure: -1,
		Scenario: "",
		ptr	: 0,
		iRow	: 0,
		remark	: "",
		dots	: "",
		log	: {
			text: "",
			Measures: []
		}
	};
var	url;
var	hTimer, hEraser;
var	hTabs		= [];
var	iTabs		= 0;
var	iEstimated	= 1,
	iDuration	= 1;
////////////////////////////////////////////////////////////////////////////////
var	GLY_TABULATION		= 0x0009,	// [->]	Tabulation key
	GLY_TABULATIONS		= 0x2409,	// [HT]	Tabulation signature
	GLY_TABULATIONG		= 0x21E5;	// ->|	Tabulation glyph
////////////////////////////////////////////////////////////////////////////////
var	GLY_MEASURE		= 0x00A7,	//	ะยง	Measure
	GLY_MEASURE_SET		= 0x20E3,	// [ ]	Set measure
	GLY_FADE_IN		= 0x21E1,	// /|\	Fade in effect
	GLY_FADE_OUT		= 0x21E3,	// \|/	Fade out effect
	GLY_DEVICE_SET		= 0x2328,	// [:]	Keyboard select
	GLY_STATE_LOAD		= 0x2397,	// [[]	Load state
	GLY_STATE_SAVE		= 0x2398,	// []]	Save state
	GLY_STATE_NULL		= 0x239A,	// [/]	Clear state
	GLY_SHOW_DELAY		= 0x23F1,	// (^)	Show delay pause
	GLY_SHOW_SPEED		= 0x23F2,	// (-)	Show speed
	GLY_SHOW_CLOCK		= 0x3390,//267B,	// /_\	Show clock frequency
	GLY_SHOW_ALERT		= 0x26A0,	// /!\	Alert
	GLY_STATE_STOP		= 0x26D4,	// (=)	Stop/Halt
	GLY_MEASURE_UP		= 0x2934,	// /\	Measure prev. line
	GLY_MEASURE_DWN		= 0x2935,	// \/	Measure next line
	GLY_MEASURE_RUN		= 0x27B0,	// _o_	Measure line run
	//
	GLY_RUN_UP		= 0x25B2;	// [^]	Run LEDs to up
	GLY_RUN_RIGHT		= 0x25B6;	// [>]	Run LEDs to right
	GLY_RUN_DOWN		= 0x25BC;	// [v]	Run LEDs to down
	GLY_RUN_LEFT		= 0x25C0;	// [<]	Run LEDs to left
	//
	GLY_STATE_LOG		= 0x2316,	// -*-	Logging the status
	GLY_STATE_PRINT		= 0x2399,	// [~]	Print the status
	GLY_SETUP_HZ		= 0x3390,	// Hz	Set up the Hz
	GLY_SETUP_MS		= 0x33B3;	// ms	Set up the ms
////////////////////////////////////////////////////////////////////////////////
//	GLazeur_Check_for_Tab
function GLYC_TAB(wc) { return (GLY_TABULATION == wc || GLY_TABULATIONG == wc || GLY_TABULATIONS == wc); }

function	ShowLevel(bits) {
	var	level = 0;
	for(bits &= 001111111111; bits > 0; bits >>= 3)
		level += bits & 1;
	return 0x191919*0+0x061903 * level;
}
function	ShowLEDs(p, q) {
	var	html = "", i, ds;
	if(!q)
		q = {
			measure: {index: -1, row: -1},
			row: -1,
			leds: p.levels,
			text: ""
		};
	for(i = 0; i < 27; ++ i) {
		html += "<span style=color:#" + ("00000" + Number(ShowLevel(q.leds[i % 9 + 1] >> (i / 9 & 3))).toString(16)).substr(-6) + ">&nbsp;&#x25CF;&nbsp;</span>";
		switch(i) {
		case 8:
			ds = (Math.floor(iDuration / 3600000) % 24) + ":" + ("0" + (Math.floor(iDuration / 60000) % 60)).substr(-2) + ":" + ("0" + (Math.floor(iDuration / 1000) % 60)).substr(-2);
			ds += "/" + (Math.floor(iEstimated / 3600000) % 24) + ":" + ("0" + (Math.floor(iEstimated / 60000) % 60)).substr(-2) + ":" + ("0" + (Math.floor(iEstimated / 1000) % 60)).substr(-2);
			html += "<span style=color:yellow>Progress: " + ("  " + Math.floor(iDuration * 100 / iEstimated)).substr(-3) + "% [" + ds + "]</span><br />";
			break;
		case 17:
			html += "<span style=color:yellow>Scenario" + (q.row >= 0 ? "-Row#" + q.row + (q.measure.index >= 0 ? " " + q.measure.row + "&#167;" + q.measure.index + "(...)" : "") : " halted...") + "</span><br />";
			break;
		case 26:
			html += "<span style=color:yellow>Logging:" + q.text + "</span>";
			break;
		}
	}
	document.getElementById("leds").innerHTML = html;
}

function parse_fraction(p) {
	var	iFractions = [
		0x2152010A,	//	1/10 .1
		0x21510109,	//	1/9	0.111
		0x215B0108,	//	1/8	0.125
		0x21500107,	//	1/7	0.143
		0x21590106,	//	1/6	0.167
		0x21550105,	//	1/5	0.2
		0x00BC0104,	//	1/4	0.25
		0x21530103,	//	1/3	0.333
		0x215C0308,	//	3/8	0.375
		0x21560205,	//	2/5	0.4
		0x00BD0102,	//	1/2	0.5
		0x21570305,	//	3/5	0.6
		0x215D0508,	//	5/8	0.625
		0x21540203,	//	2/3	0.667
		0x00BE0304,	//	3/4	0.75
		0x21580405,	//	4/5	0.8
		0x215A0506,	//	5/6	0.833
		0x215E0708,	//	7/8	0.875
		0x21890003	//	0/3
	],	i, wcode;
	if(p.cmd.c_ptr > '0' && p.cmd.c_ptr <= '9') {
		p.tmp.iNumerator = 0;
		while(p.cmd.c_ptr >= '0' && p.cmd.c_ptr <= '9')
			p.tmp.iNumerator = p.tmp.iNumerator * 10 + +p.cmd.c_ptr_pp;
	} else
	if(p.cmd.c_ptr == '0') {
		p.tmp.iNumerator = 0;
		while(p.cmd.c_ptr >= '0' && p.cmd.c_ptr <= '7')
			p.tmp.iNumerator = p.tmp.iNumerator * 8 + +p.cmd.c_ptr_pp;
	} else
		p.tmp.iNumerator = -1;
	p.tmp.iDenominator = -1;
	wcode = p.cmd.a_ptr;
	i = 10000;
	if(p.tmp.iNumerator > 0)
		switch(wcode) {
		case 0x25:	i /= 10;
		case 0x2030:	i /= 10;
		case 0x2031:	p.tmp.iDenominator = i;
				p.cmd.ptr ++;
				return p;
		}		
	do {
		i = iFractions.length;
		while(i --) {
			n = iFractions[i];
			if(n >> 16 == wcode) {
				if(p.tmp.iNumerator < 1)
					p.tmp.iNumerator = (n >> 8) & 255;
				else
				if(p.tmp.iDenominator < 1)
					p.tmp.iNumerator = p.tmp.iNumerator * (n & 255) + ((n >> 8) & 255);
				else
					p.tmp.iNumerator *= (n >> 8) & 255;
				if(p.tmp.iDenominator < 1)
					p.tmp.iDenominator = n & 255;
				else
					p.tmp.iDenominator *= n & 255;
				for(i = 2; p.tmp.iNumerator / i >= 1 && p.tmp.iDenominator / i >= 1; ++ i) {
					if(p.tmp.iNumerator == Math.floor(p.tmp.iNumerator / i) * i && p.tmp.iDenominator == Math.floor(p.tmp.iDenominator / i) * i)
						p.tmp.iNumerator /= i,
						p.tmp.iDenominator /= i,
						i = 1;
				}
				wcode = p.cmd.a_pp_ptr;
				break;
			}
		}
	} while(i >= 0);	//console.log("(" + p.tmp.iNumerator + "/" + p.tmp.iDenominator + ") == " + Math.floor(p.tmp.iNumerator / p.tmp.iDenominator) + "(" + (p.tmp.iNumerator % p.tmp.iDenominator) + "/" + p.tmp.iDenominator + ")");
	return p;
}
function play_effect(p, pp) {
	var	mode = 0,
		code,
		index;
	var	lo, hi;
	//
	switch(p.cmd.a_ptr) {
	case GLY_FADE_IN:
	case GLY_FADE_OUT:
	case GLY_STATE_NULL:
		mode = p.cmd.a_ptr_pp;
	}
	code = p.cmd.a_ptr;
	if(code >= 0x2800 && code <= 0x28FF) {
		index = p.tmp.iNumerator;
		if(index < 1 || index > 9)
			index = p.tmp.iKeyboard;
		if(index < 1 || index > 9)
			return false;
		while(code >= 0x2800 && code <= 0x28FF) {
			if(code == 0x28C0) {
				code = pp.dots.charCodeAt(0);
				pp.dots = pp.dots.substr(1);
			}
			code &= 255;
			switch(mode) {
			case GLY_FADE_IN:
				lo = 001111111111 * (code & 7),
				hi = 001111111111 * ((code >> 3) & 7);
				if((code & 0100) == 0)
					pp.levels[index] = (pp.levels[index] & ~lo) | ((pp.levels[index] << 3) & lo) | (pp.levels[index] & lo);
				index = index % 9 + 1;
				if((code & 0200) == 0)
					pp.levels[index] = (pp.levels[index] & ~hi) | ((pp.levels[index] << 3) & hi) | (pp.levels[index] & hi);
				index = index % 9 + 1;
				break;
			case GLY_FADE_OUT:
				lo = 001111111110 * (code & 7),
				hi = 001111111110 * ((code >> 3) & 7);
				if((code & 0100) == 0)
					pp.levels[index] = (pp.levels[index] & ~lo) | ((pp.levels[index] & lo) >> 3);
				index = index % 9 + 1;
				if((code & 0200) == 0)
					pp.levels[index] = (pp.levels[index] & ~hi) | ((pp.levels[index] & hi) >> 3);
				index = index % 9 + 1;
				break;
			default:
				lo = 001111111111 * (code & 7),
				hi = 001111111111 * ((code >> 3) & 7);
				if((code & 0100) == 0)
					pp.levels[index] = (pp.levels[index] & 030000000000) | lo;
				index = index % 9 + 1;
				if((code & 0200) == 0)
					pp.levels[index] = (pp.levels[index] & 030000000000) | hi;
				index = index % 9 + 1;
				break;
			}
			code = p.cmd.a_pp_ptr;
		}
		return true;
	}
	if(GLY_DEVICE_SET == code && p.tmp.iDenominator < 0) {
		if(p.tmp.iNumerator >= 1 && p.tmp.iNumerator <= 9)
			p.tmp.iKeyboard = p.tmp.iNumerator;
		else
		if(p.tmp.iNumerator >= 1 && p.tmp.iNumerator >= 11)
			pp.order = p.tmp.iNumerator;
		else
		if(p.tmp.iNumerator < 0 && mode == GLY_FADE_IN)
			p.tmp.iKeyboard = p.tmp.iKeyboard % 9 + 1;
		else
		if(p.tmp.iNumerator < 0 && mode == GLY_FADE_OUT)
			p.tmp.iKeyboard = (p.tmp.iKeyboard + 7) % 9 + 1;
		p.cmd.ptr ++;
		return true;
	}
	if(GLY_RUN_UP == code && p.tmp.iNumerator < 0) {
		p.cmd.ptr ++;
		for(index = 1; index <= 9; ++ index) {
			code = pp.levels[index];
			pp.levels[index] = (code & 030000000000) | ((code & 006666666666) >> 1) | ((code & 001111111111) << 2);
		}
		return true;
	}
	if(GLY_RUN_RIGHT == code && p.tmp.iNumerator < 0) {
		p.cmd.ptr ++;
		index = 9;
		code = pp.levels[index];
		while(index > 1)
			pp.levels[index] = pp.levels[index - 1],
			index --;
		pp.levels[index] = code;
		return true;
	}
	if(GLY_RUN_DOWN == code && p.tmp.iNumerator < 0) {
		p.cmd.ptr ++;
		for(index = 1; index <= 9; ++ index) {
			code = pp.levels[index];
			pp.levels[index] = (code & 030000000000) | ((code & 004444444444) >> 2) | ((code & 003333333333) << 1);
		}
		return true;
	}
	if(GLY_RUN_LEFT == code && p.tmp.iNumerator < 0) {
		p.cmd.ptr ++;
		index = 1;
		code = pp.levels[index];
		while(index < 9)
			pp.levels[index] = pp.levels[index + 1],
			index ++;
		pp.levels[index] = code;
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////
//	FUNCTION:	Get measure row
//	PURPOSE:	Find the target row
//	Example:
//	|This is measure's commentary
//	|	[1]		This is row #1
//	|This is measure's commentary #2	
//	|	[2]		This is row #2
//	|This is measure's finish
//	|
////////////////////////////////////////////////////////////////////////////////
function	parse_measure_rows(p, row) {
	var	rows	= 0;
	//
	while(row > 0) {
		while(0x000D != p.cmd.a_ptr) {
			if(!p.cmd.a_ptr)
				return rows;
			p.cmd.ptr ++;
		}
		if(0x000A == p.cmd.a_pp_ptr)
			p.cmd.ptr ++;
		++ rows;
		if(GLYC_TAB(p.cmd.a_ptr))
			p.cmd.ptr ++, -- row;
		else
		if(p.cmd.a_ptr < 32)
			return rows;
		else
			p.remark = p.cmd.str.split(/\r|\n/)[0];
	};
	return rows;
}
function	parse_measure(p, iMeasure, ptr) {
	var	pm	= p.Measures[iMeasure];
	var	preps	= [];
	var	nreps	= [];
	var	dreps	= [];
	var	nlaps	= -1;
	var	iRow;
	var	nTabs	= 0;
	var	i, tmp, wcode, ascii;
	//
	var	iDelay		= 0;
	//
	pm.remark = "";
	if(ptr >= 0) {
		pm = p;
		pm.cmd.ptr ++;
		iRow = p.Measures[iMeasure].iRow;
	} else {
		pm.cmd.ptr = 0;
		iRow = parse_measure_rows(pm, p.Measures[iMeasure].iRow);
		while(GLYC_TAB(pm.cmd.a_ptr))
			++ pm.cmd.ptr;
	}
	pm.tmp.iKeyboard = p.iKeyboard;
	while(pm.cmd.a_ptr >= 32) {
		while(pm.cmd.a_ptr == 32)
			++ pm.cmd.ptr;
		parse_fraction(pm);
		wcode = pm.cmd.a_ptr;
		ascii = pm.cmd.c_ptr;
		if((GLY_MEASURE == wcode || GLY_MEASURE_SET == wcode) && pm.tmp.iNumerator >= 0 && pm.tmp.iDenominator < 0) {
			p.Measures[iMeasure].iRow = pm.tmp.iNumerator;
			++ pm.cmd.ptr;
			continue;
		}
		if(GLY_MEASURE_UP == wcode && pm.tmp.iDenominator < 0) {
			if(pm.tmp.iNumerator > 0)
				p.Measures[iMeasure].iRow = p.Measures[iMeasure].iRow > pm.tmp.iNumerator ? p.Measures[iMeasure].iRow - pm.tmp.iNumerator : 1;
			else
			if(pm.Measures[iMeasure].iRow > 1)
				-- pm.Measures[iMeasure].iRow;
			++ pm.cmd.ptr;
			continue;
		}
		if(GLY_MEASURE_DWN == wcode && pm.tmp.iDenominator < 0) {
			if(pm.tmp.iNumerator > 0)
				p.Measures[iMeasure].iRow += pm.tmp.iNumerator;
			else
				++ p.Measures[iMeasure].iRow;
			++ pm.cmd.ptr;
			continue;
		}
		if(GLY_STATE_NULL == wcode && pm.tmp.iNumerator < 0 && pm.tmp.iDenominator < 0) {
			p.log.text = "";
			pm.cmd.ptr ++;
			continue;
		}
		if(GLY_STATE_PRINT == wcode && pm.tmp.iNumerator < 0 && pm.tmp.iDenominator < 0) {
			++ pm.cmd.ptr;
			p.log.text = pm.remark.replace(/[\u2080-\u2089]/g,
				function(str) {
					var	index = str.charCodeAt(0) - 0x2080;
					if(index > 0)
						return nlaps >= index - 1 ? nreps[nlaps - index + 1] : "?";
					return "" + iRow;
				}
			).replace(/\xA7/g, "" + p.iMeasure).replace(/[\u2070\xB9\xB2\xB3\u2074-\u2079]/g,
				function(str) {
					var	index = str.charCodeAt(0);
					index = index == 0xB9 ? 1 : index & 15;
					if(index > 0)
						return p.tmp.nReps.length >= index ? p.tmp.nReps[p.tmp.nReps.length - index] : "?";
					return "" + p.iRow;
				}
			);
			continue;
		}
		if(GLY_SETUP_MS == wcode) {
			++ pm.cmd.ptr;
			if(pm.tmp.iNumerator > 0 && pm.tmp.iDenominator > 0)
				p.Measures[iMeasure].iDelayMul = pm.tmp.iNumerator,
				p.Measures[iMeasure].iDelayDiv = pm.tmp.iDenominator;
			else
			if(pm.iNumerator > 0)
				p.Measures[iMeasure].iDelay = pm.tmp.iNumerator,
				p.Measures[iMeasure].iDelayMul = 1,
				p.Measures[iMeasure].iDelayDiv = 1;
			else
				p.Measures[iMeasure].iDelay = p.iDelay * p.iDelayMul / p.iDelayDiv,
				p.Measures[iMeasure].iDelayMul = 1,
				p.Measures[iMeasure].iDelayDiv = 1;
			continue;
		}
		if(GLY_SHOW_DELAY == wcode) {
			if(p.Measures[iRow].iDelayDiv > 0)
				p.movie.push({
					measure	:{index: iMeasure, row: iRow},
					delay	:pm.iDelay * (pm.tmp.iNumerator > 0 ? pm.tmp.iNumerator * pm.iDelayMul : pm.iDelayMul) / (pm.tmp.iDenominator > 0 ? pm.tmp.iDenominator * pm.iDelayDiv : pm.iDelayDiv),
					leds	:[].concat(p.levels),
					row	:p.iRow,
					text	:p.log.text
				});
			else
				p.log.Measures[iMeasure][iRow] = true;
			++ pm.cmd.ptr;
			continue;
		}
		if(';' == ascii) {
			++ pm.cmd.ptr;
			if(ptr >= 0) {
				p.cmd.ptr = pm.cmd.ptr;
				return;
			}
			if(nreps.length > 0) {
				tmp = nreps[nreps.length - 1];
				if(tmp > dreps[dreps.length - 1])
					continue;
				-- nreps[nreps.length - 1];
				if(tmp > 1)
					continue;
				tmp = 0;
				do {
					ascii = pm.cmd.c_pp_ptr;
					if('(' == ascii)
						++ tmp;
					if(')' == ascii)
						-- tmp;
				} while(ascii != '' && tmp >= 0);
			}
		}
		if(')' == ascii) {
			if(ptr >= 0) {
				p.cmd.ptr = ++ pm.cmd.ptr;
				return;
			}
			if(nlaps >= 0) {
				if(nreps[nlaps] -- > 1) {
					pm.cmd.ptr = preps[nlaps];
					continue;
				}
				-- nlaps;
			}
			++ pm.cmd.ptr;
			continue;
		}
		if('(' == ascii) {
			++ pm.cmd.ptr;
			if(pm.tmp.iNumerator > 0 && pm.tmp.iDenominator < 0) {
				++ nlaps;
				preps[nlaps] = pm.ptr;
				nreps[nlaps] = pm.tmp.iNumerator;
				continue;
			}
			break;
		}
		if(play_effect(pm, p))
			continue;
		++ pm.cmd.ptr;
	};
}

function	animate() {
	var	q = LEDs.movie.shift(), hPrg = document.getElementById("Progress");
	if(q) {
		var	i, sPrg, iPrg;
		ShowLEDs(LEDs, q);
		hTimer = setTimeout("animate()", q.delay);
		iPrg = Math.floor(iDuration * 100 / iEstimated);
		sPrg = "";
		for(i = 0; i < iPrg; i += 2)
			sPrg += "\u2593";
		sPrg += i == iPrg ? "\u2593" : "\u2592";
		while(i < 100)
			sPrg += "\u2591",
			i += 2;
		hPrg.textContent = sPrg;
		iDuration += q.delay;
	} else
	if(iEstimated > 1) {
		hPrg.textContent = "Completed! Click for share this scenario.";
		ShowLEDs(LEDs);
	}
}

function	parse(p, cmd) {
	var	wcode,
		ascii,
		tmp;
	p.Scenario = [];
	p.movie = [];
	cmd = cmd.split(/\r?\n/);
	p.iMeasure = 10;
	while(p.iMeasure -- > 0)
		p.log.Measures[p.iMeasure] = [];
	cmd.forEach(function(str) {
		if(str != "") {
			str = str.split(/[\t\u2409\u21E5]+/);
			if((str[0].charCodeAt(0) >= 48 && str[0].charCodeAt(0) <= 57 && str[0].charCodeAt(1) == GLY_MEASURE_SET)
			|| (str[0].charCodeAt(1) >= 48 && str[0].charCodeAt(1) <= 57 && str[0].charCodeAt(0) == GLY_MEASURE)) {
				p.iMeasure = str[0].charCodeAt(1) == GLY_MEASURE_SET ? str[0].charCodeAt(0) - 48 : str[0].charCodeAt(1) - 48;
				p.Measures[p.iMeasure].cmd = new WCHAR(str.join("\t").substr(2));
				p.Measures[p.iMeasure].iRow = 0;
				p.Measures[p.iMeasure].ptr = 0;
				return;
			}
			if(str[0] != "" && p.iMeasure >= 0) {
				if(p.Measures[p.iMeasure].cmd.str == "")
					tmp = "";
				else
					tmp = "\r\n";
				p.Measures[p.iMeasure].cmd.concat = tmp + str.join("\t").substr(0);
				return;
			}
			if(str[1] != "" && p.iMeasure >= 0) {
				if(p.Measures[p.iMeasure].cmd.str == "")
					tmp = "";
				else
					tmp = "\r\n";
				p.Measures[p.iMeasure].cmd.concat = tmp + str.join("\t").substr(0);
				return;
			}
			if(str[0] == "" && str[1] != "" && p.iMeasure < 0) {
				p.Scenario.push(str.join("\t"));
				return;
			}
			if(str[0] != "" && p.iMeasure < 0) {
				p.Scenario.push(str.join("\t"));
				return;
			}
		}
		p.iMeasure = -1;
	});
	p.iDelay = 1000,
	p.iDelayMul = 1,
	p.iDelayDiv = 1;
	p.iRow = 0;
	p.remark = "";
	p.dots = ""
	p.Scenario//.split(/\r?\n/)
	.forEach(function(str) {
		p.cmd = new WCHAR(str);
		p.iRow ++;
		p.log.text = "";
		p.tmp.pReps = [];
		p.tmp.nReps = [];
		p.tmp.dReps = [];
		if(!GLYC_TAB(p.cmd.a_ptr_pp)) {
			if(str.charCodeAt(0) == 0x28C0)
				p.dots = str.substr(1);
			else
				p.remark = str;
			return;
		}
		while(GLYC_TAB(p.cmd.a_ptr))
			++ p.cmd.ptr;
		while(p.cmd.a_ptr >= 32) {
			while(p.cmd.a_ptr == 32)
				++ p.cmd.ptr;
			parse_fraction(p);
			wcode = p.cmd.a_ptr;
			ascii = p.cmd.c_ptr;
			p.iNumerator = p.tmp.iNumerator;
			p.iDenominator = p.tmp.iDenominator;
			if(GLY_MEASURE_SET == wcode && p.iNumerator >= 0 && p.iNumerator <= 9 && p.iDenominator < 0) {
				p.iMeasure = p.iNumerator;
				++ p.ptr;
				continue;
			}
			if(GLY_MEASURE == wcode) {
				wcode = p.cmd.a_pp_ptr;
				ascii = p.cmd.c_ptr;
				if(wcode >= 0x30 && wcode <= 0x39)
					p.iMeasure = wcode - 0x30,
					p.cmd.ptr ++;
				else
				if(p.iMeasure >= 0 && p.iNumerator < 0 && '(' == ascii) {
					parse_measure(p, p.iMeasure, 1);
					continue;
				}
				if(p.iMeasure >= 0 && p.iNumerator >= 0 && p.iDenominator < 0)
					p.Measures[p.iMeasure].iRow = p.iNumerator;
				continue;
			}
			if(GLY_MEASURE_UP == wcode && p.iDenominator < 0 && p.iMeasure >= 0) {
				if(p.iNumerator > 0)
					p.Measures[p.iMeasure].iRow = p.Measures[p.iMeasure].iRow > p.iNumerator ? p.Measures[p.iMeasure].iRow - p.iNumerator : 1;
				else
				if(p.Measures[p.iMeasure].iRow > 1)
					-- p.Measures[p.iMeasure].iRow;
				++ p.cmd.ptr;
				continue;
			}
			if(GLY_MEASURE_DWN == wcode && p.iDenominator < 0 && p.iMeasure >= 0) {
				if(p.iNumerator > 0)
					p.Measures[p.iMeasure].iRow += p.iNumerator;
				else
					++ p.Measures[p.iMeasure].iRow;
				++ p.cmd.ptr;
				continue;
			}
			if(GLY_MEASURE_RUN == wcode && p.iDenominator < 0 && p.iMeasure >= 0) {
				parse_measure(p, p.iMeasure);
				++ p.cmd.ptr;
				continue;
			}
			if(GLY_SHOW_CLOCK == wcode && p.iNumerator > 0 && p.iDenominator < 0) {
				p.speed = p.iNumerator;
				++ p.cmd.ptr;
				continue;
			}
			if(GLY_STATE_NULL == wcode && p.tmp.iNumerator < 0 && p.tmp.iDenominator < 0) {
				p.log.text = "";
				++ p.cmd.ptr;
				continue;
			}
			if(GLY_STATE_PRINT == wcode && p.tmp.iNumerator < 0 && p.tmp.iDenominator < 0) {
				++ p.cmd.ptr;
				p.log.text = p.remark.replace(/[\u2080-\u2089]/g,
					function(str) {
						var	index = str.charCodeAt(0) - 0x2080;
						if(index > 0) {
							if(p.tmp.nReps.length < index)
								return "?";
							if(p.tmp.dReps[p.tmp.dReps.length - index] < 1)
								return "" + p.tmp.nReps[p.tmp.nReps.length - index];
							return "" + (Math.floor(p.tmp.nReps[p.tmp.nReps.length - index] / p.tmp.dReps[p.tmp.dReps.length - index]));
						}
						return "" + p.iRow;
					}
				).replace(/\xA7/g, (p.iMeasure < 0 ? "\xA7" : "" + p.iMeasure));
				continue;
			}
			if(GLY_SETUP_MS == wcode) {
				++ p.cmd.ptr;
				if(p.iNumerator > 0 && p.iDenominator > 0)
					p.iDelayMul = p.iNumerator,
					p.iDelayDiv = p.iDenominator;
				else
				if(p.iNumerator > 0)
					p.iDelay = p.iNumerator,
					p.iDelayMul = 1,
					p.iDelayDiv = 1;
				else
					p.iDelayMul = 1,
					p.iDelayDiv = 1;
				continue;
			}
			if(GLY_SHOW_DELAY == wcode) {
				p.movie.push({
					measure	:{index: -1, row: -1},
					delay	:p.iDelay * (p.iNumerator > 0 ? p.iNumerator * p.iDelayMul : p.iDelayMul) / (p.iDenominator > 0 ? p.iDenominator * p.iDelayDiv : p.iDelayDiv),
					leds	:[].concat(p.levels),
					row	:p.iRow,
					text	:p.log.text
				});
				++ p.cmd.ptr;
				continue;
			}
			if('(' == ascii) {
				++ p.cmd.ptr;
				if(p.iNumerator > 0) {
					p.tmp.pReps.push(p.cmd.ptr);
					p.tmp.nReps.push(p.iNumerator);
					p.tmp.dReps.push(p.iDenominator);
					continue;
				}
				break;
			}
			if(';' == ascii) {
				++ p.cmd.ptr;
				if(p.tmp.nReps.length > 0) {
					tmp = p.tmp.nReps[p.tmp.nReps.length - 1];
					if(tmp > p.tmp.dReps[p.tmp.dReps.length - 1])
						continue;
					-- p.tmp.nReps[p.tmp.nReps.length - 1];
					if(tmp > 1)
						continue;
					tmp = 0;
					do {
						ascii = p.cmd.c_pp_ptr;
						if('(' == ascii)
							++ tmp;
						if(')' == ascii)
							-- tmp;
					} while(ascii != '' && tmp >= 0);
				}
			}
			if(')' == ascii) {
				if(p.tmp.nReps.length > 0) {// 2 1/3 >> 7/3 1#4/3 2#1/3
					tmp = p.tmp.dReps[p.tmp.dReps.length - 1];
					if(tmp > 0) {
						if((p.tmp.nReps[p.tmp.nReps.length - 1] -= tmp) > 0) {
							p.cmd.ptr = p.tmp.pReps[p.tmp.pReps.length - 1];
							continue;
						}
					} else
					if(-- p.tmp.nReps[p.tmp.nReps.length - 1] > 0) {
						p.cmd.ptr = p.tmp.pReps[p.tmp.pReps.length - 1];
						continue;
					}
					p.tmp.nReps.pop();
					p.tmp.pReps.pop();
					p.tmp.dReps.pop();
				}
				++ p.cmd.ptr;
				continue;
			}
			p.tmp.iKeyboard = p.iKeyboard;
			if(play_effect(p, p)) {
				p.iKeyboard = p.tmp.iKeyboard;
			} else
				++ p.cmd.ptr;
		}
	});
	clearTimeout(hTimer);
	iDuration = 0;
	iEstimated = 0;
	for(var i in p.log.Measures) {
		var rows = p.log.Measures[i];
		for(var j in rows) {
			if(!!rows[j]) {
				++ iDuration;
				alert("Error in paragraph#" + i + " row#" + j);
			}
		}
	};
	p.movie.forEach(function(iDelay) { iEstimated += +iDelay.delay; });
	document.getElementById("Progress").textContent = "Halted";
	if(iEstimated > 0 && iDuration == 0)
		animate();
}

function insertAtCursor(hText, szChar) {
    //IE support
	if(document.selection) {
		hText.focus();
		sel = document.selection.createRange();
		sel.text = szChar;
	} else
	//MOZILLA and others
	if(hText.selectionStart || hText.selectionStart == '0') {
		var	startPos	= hText.selectionStart;
		var	endPos		= hText.selectionEnd;
		hText.value = hText.value.substring(0, startPos)
			+ szChar
			+ hText.value.substring(endPos, hText.value.length);
		hText.selectionStart = startPos + szChar.length;
		hText.selectionEnd = hText.selectionStart;
	} else
		hText.value += szChar;
}
function insertOperator(e) {
	if(e.target && (e.target.nodeName == "TD" || e.target.nodeName == "SPAN")) {
		insertAtCursor(document.getElementById("Scenario"), e.target.textContent.replace(/\u23CE\r/g, "\r\n"));
		document.getElementById("Scenario").focus();
	}
}
function hidingTable(e) {
	hEraser = setTimeout(function() {
		hTabs[iTabs].style.display = "none";
		iTabs = 0;
		hTabs[iTabs].style.display = "block";
	}, 500);
}
function holdingTable(e) {
	clearTimeout(hEraser);
	hEraser = 0;
}

function main() {
	var	layouts = [
		[
			"0x00002077:Iteration of basic cycle #7",
			"0x00002078:Iteration of basic cycle #8",
			"0x00002079:Iteration of basic cycle #9",
			"0x00000037:Number @",
			"0x00000038:Number @",
			"0x00000039:Number @",
			"0x00002087:Iteration of current cycle #7",
			"0x00002088:Iteration of current cycle #8",
			"0x00002089:Iteration of current cycle #9",
			"0x00002074:Iteration of basic cycle #4",
			"0x00002075:Iteration of basic cycle #5",
			"0x00002076:Iteration of basic cycle #6",
			"0x00000034:Number @",
			"0x00000035:Number @",
			"0x00000036:Number @",
			"0x00002084:Iteration of current cycle #4",
			"0x00002085:Iteration of current cycle #5",
			"0x00002086:Iteration of current cycle #6",
			"0x000000B9:Iteration of basic cycle #1",
			"0x000000B2:Iteration of basic cycle #2",
			"0x000000B3:Iteration of basic cycle #3",
			"0x00000031:Number @",
			"0x00000032:Number @",
			"0x00000033:Number @",
			"0x00002081:Iteration of current cycle #1",
			"0x00002082:Iteration of current cycle #2",
			"0x00002083:Iteration of current cycle #3",
			"0x00002070:Index of basic row",
			"0x0000239A:Clear status",
			"0x000023F1:Adjust current intervals and wait for interval - \xBD@..999\xBC\xBD@	Reset to default interval - 0@		Wait for interval - @",
			"0x00000030:Number @",
			"0x00000028:Open the bracket			Loop for n-times - 1(...) .. 999(...)",
			"0x00000029:Closing bracket",
			"0x00002080:Index of current row",
			"0x00002399:Show status",
			"0x24090009:Tabulation",
			"0x21E50009:Tabulation",
			"0x0003267D:Special FX				---",
			"0x000023F2:Timing				---",
			"0x000033B3:Set the timer delaying interval(ms) - 1@ .. 10000@	Reset coefficients - 0@ / @	Change coefficients - \xBD@..9\xBC\xBD@",
			"0x00022318:Operators",
			"0x00002397:Push history			--- comming soon",
			"0x00002398:Pop history				--- comming soon",
			"0x0001283F:Dots",
			"0x23CE000D:Enter",
			"0x0000215E:7/8",
			"0x0000215D:5/8",
			"0x00002157:3/5",
			"0x00A70037:Define/append paragraph #7		Select paragraph #7",
			"0x00A70038:Define/append paragraph #8		Select paragraph #8",
			"0x00A70039:Define/append paragraph #9		Select paragraph #9",
			"0x00002150:1/7",
			"0x0000215B:1/8",
			"0x00002151:1/9",
			"0x000000BE:3/4",
			"0x00002158:4/5",
			"0x0000215A:5/6",
			"0x00A70034:Define/append paragraph #4		Select paragraph #4",
			"0x00A70035:Define/append paragraph #5		Select paragraph #5",
			"0x00A70036:Define/append paragraph #6		Select paragraph #6",
			"0x000000BC:1/4",
			"0x00002155:1/5",
			"0x00002159:1/6",
			"0x00002156:2/5",
			"0x00002154:2/3",
			"0x0000215C:3/8",
			"0x00A70031:Define/append paragraph #1		Select paragraph #1",
			"0x00A70032:Define/append paragraph #2		Select paragraph #2",
			"0x00A70033:Define/append paragraph #3		Select paragraph #3",
			"0x00002152:1/10",
			"0x000000BD:1/2",
			"0x00002153:1/3",
			"0x000027B0:Replay line of paragraph",
			"0x000026A0:Alert",
			"0x000026D4:Halt",
			"0x00A70030:Define/append paragraph #0		Select paragraph #0",
			"0x000000A7:Define/append paragraph - @0 .. @9	Select paragraph - @0 .. @9		Switch to paragraph row - 0@ .. 999@",
			"0x00A70028:Active paragraph settings - @(...)",
			"0x00000025:percent",
			"0x00002030:per mille",
			"0x00002031:per 10 milles"
		],	[
		],	[
			"0x0000246A:Sub-label 11",
			"0x0000246B:Sub-label 12",
			"0x0000246C:Sub-label 13",
			"0x0000246D:Sub-label 14",
			"0x0000246E:Sub-label 15",
			"0x0000246F:Sub-label 16",
			"0x00002470:Sub-label 17",
			"0x00002471:Sub-label 18",
			"0x00002472:Sub-label 19",
			"0x00002473:Sub-label 20",
			"0x00002460:Sub-label 1",
			"0x00002461:Sub-label 2",
			"0x00002462:Sub-label 3",
			"0x00002463:Sub-label 4",
			"0x00002464:Sub-label 5",
			"0x00002465:Sub-label 6",
			"0x00002466:Sub-label 7",
			"0x00002467:Sub-label 8",
			"0x00002468:Sub-label 9",
			"0x00002469:Sub-label 10",
			"0x000024C6:Label Q",
			"0x000024CC:Label W",
			"0x000024BA:Label E",
			"0x000024C7:Label R",
			"0x000024C9:Label T",
			"0x000024CE:Label Y",
			"0x000024CA:Label U",
			"0x000024BE:Label I",
			"0x000024C4:Label O",
			"0x000024C5:Label P",
			"0x000024B6:Label A",
			"0x000024C8:Label S",
			"0x000024B9:Label D",
			"0x000024BB:Label F",
			"0x000024BC:Label G",
			"0x000024BD:Label H",
			"0x000024BF:Label J",
			"0x000024C0:Label K",
			"0x000024C1:Label L",
			"0x00000020:",
			"0x00000020:",
			"0x000024CF:Label Z",
			"0x000024CD:Label X",
			"0x000024B8:Label C",
			"0x000024CB:Label V",
			"0x000024B7:Label B",
			"0x000024C3:Label N",
			"0x000024C2:Label M",
			"0x00000020:",
			"0x00000020:",
			"0x0000248E:Dotted key 7",
			"0x0000248F:Dotted key 8",
			"0x00002490:Dotted key 9",
			"0x00002498:Dotted key 17",
			"0x00002499:Dotted key 18",
			"0x0000249A:Dotted key 19",
			"0x00000020:",
			"0x003720E3:Number key 7",
			"0x003820E3:Number key 8",
			"0x003920E3:Number key 9",
			"0x0000248B:Dotted key 4",
			"0x0000248C:Dotted key 5",
			"0x0000248D:Dotted key 6",
			"0x00002495:Dotted key 14",
			"0x00002496:Dotted key 15",
			"0x00002497:Dotted key 16",
			"0x00000020:",
			"0x003420E3:Number key 4",
			"0x003520E3:Number key 5",
			"0x003620E3:Number key 6",
			"0x00002488:Dotted key 1",
			"0x00002489:Dotted key 2",
			"0x0000248A:Dotted key 3",
			"0x00002492:Dotted key 11",
			"0x00002493:Dotted key 12",
			"0x00002494:Dotted key 13",
			"0x00000020:",
			"0x003120E3:Number key 1",
			"0x003220E3:Number key 2",
			"0x003320E3:Number key 3",
			"0x00000020:",
			"0x00000020:",
			"0x00000020:",
			"0x00002491:Dotted key 10",
			"0x00000020:",
			"0x00000020:",
			"0x00000020:",
			"0x003020E3:Number key 0",
			"0x00000020:",
			"0x00000020:",
		],	[
			"0x00002679:Special FX #7			---",
			"0x0000267A:Special FX +			---",
			"0x0000267D:Special FX ++			---",
			"0x00002676:Special FX #4			---",
			"0x00002677:Special FX #5			---",
			"0x00002678:Special FX #6			---",
			"0x00002673:Special FX #1			---",
			"0x00002674:Special FX #2			---",
			"0x00002675:Special FX #3			---",
			"0x00002672:Special FX #0			---",
			"0x0000267A:Special FX				---",
			"0x0000267B:Special FX+++			---",
			"0x00002637:Trigram FX #7 - Earth		---",
			"0x000021E3:Fade out FX - @\u2878\u283F\u2887	Decrement the keyboard selector - @\u2328",
			"0x000021E1:Fade in FX - @\u2878\u283F\u2887	Increment the keyboard selector - @\u2328",
			"0x00002634:Trigram FX #4 - Wind		---",
			"0x00002635:Trigram FX #5 - Water		---",
			"0x00002636:Trigram FX #6 - Mountain		---",
			"0x00002631:Trigram FX #1 - Lake		---",
			"0x00002632:Trigram FX #2 - Fire		---",
			"0x00002633:Trigram FX #3 - Thunder		---",
			"0x00002630:Trigram FX #0 - Heaven		---",
			"0x000025B2:Scroll up",
			"0x000025B6:Scroll right",
			"0x00003390:Set the LEDs refreshing frequency(Hz) - 1@ .. 1000@",
			"0x000025C0:Scroll left",
			"0x000025BC:Scroll down",
			"0x00002935:Go to next line in paragraph	Skip lines in paragraph - 1@ .. 999@",
			"0x00002328:Select keyboard - 0@ .. 9@		Set keyboards order - 11@ .. 999999999@",
			"0x00002934:Go to previous line of paragraph	Back up to lines in paragraph - 1@ .. 999@",
		]
	];
	hTabs[0] = document.getElementById("Numbers");
	hTabs[1] = document.getElementById("Brailles");
	hTabs[2] = document.getElementById("Operators");
	hTabs[3] = document.getElementById("Effects");
	var	hTab, hRow, hCell, pattern;
	var	x, y, i, n, order, tmp;
	var	order = 32290810;
	//
	hTab = hTabs[(order - order % 10) / 10 % 10];
	for(y = -1; y < 8; ++ y) {
		hRow = hTab.insertRow(y + 1);
		for(x = -1; x < 8; ++ x) {
			tmp = x < 0 ? y < 0 ? [0x28C0, "Using dots-pattern"] : [0x2880 + y, "Left dots only"] : y < 0 ? [0x2840 + x * 8, "Right dots only"] : [0x2800 + x * 8 + y, "Paste this six dots"];
			hCell = hRow.insertCell(x + 1);
			hCell.className = "operator";
			hCell.width = "32px";
			hCell.title = tmp[1];
			hCell.innerHTML = "&#" + tmp[0] + ";";
			hCell.innerHTML = "<span style=position:absolute>&#" + tmp[0] + ";</span><span style=color:yellow>&#x283F;</span>";
			hCell.title = hCell.title.replace(/[\t]+/g, "\r\n").replace(/@/g, hCell.textContent);
			hCell.addEventListener("click", insertOperator);
		}
	}
	hTab.style.display = "none";
	hTab.addEventListener("mouseover", holdingTable);
	hTab.addEventListener("mouseout", hidingTable);
	do {
		order = (order - order % 100) / 100;
		iTabs = (order - order % 10) / 10 % 10;
		hTab = hTabs[iTabs];
		pattern = layouts[iTabs];
		if(iTabs > 0) {
			hTab.addEventListener("mouseover", holdingTable);
			hTab.addEventListener("mouseout", hidingTable);
		}
		for(y = 0; y < 9; ++ y) {
			hRow = hTab.insertRow(y);
			for(x = 0; x <= order % 10; ++ x) {
				tmp = pattern.shift().split(":");
				hCell = hRow.insertCell(x);
				hCell.className = "operator";
				hCell.width = "32px";
				hCell.title = tmp[1];
				tmp = parseInt(tmp[0]);
				if(tmp < 65535) {
					hCell.innerHTML = "&#" + tmp + ";";
					hCell.addEventListener("click", insertOperator);
				} else
				if((tmp >> 16) < 9) {
					hCell.className = "switch_" + (tmp >> 16);
					hCell.innerHTML = "&#" + (tmp & 65535) + ";";
					switch(tmp >> 16) {
					case 1:	hCell.addEventListener("click", function() {
						hTabs[iTabs].style.display = 'none'; iTabs = 1;
						hTabs[iTabs].style.display = 'block';		});
						break;
					case 2:	hCell.addEventListener("click", function() {
						hTabs[iTabs].style.display = 'none'; iTabs = 2;
						hTabs[iTabs].style.display = 'block';		});
						break;
					case 3:	hCell.addEventListener("click", function() {
						hTabs[iTabs].style.display = 'none'; iTabs = 3;
						hTabs[iTabs].style.display = 'block';		});
						break;
					}
				} else {
					hCell.innerHTML = "&#" + (tmp >> 16) + ";&#" + (tmp & 65535) + ";";
					hCell.addEventListener("click", insertOperator);
				}
				hCell.title = hCell.title.replace(/[\t]+/g, "\r\n").replace(/@/g, hCell.textContent);
			}
		}
		hTab.style.display = "none";
	} while(order >= 100);
	iTabs = 0;
	hTabs[iTabs].style.display = "block";
	for(i = 0; i < 10; ++ i) {
		LEDs.Measures[i] = {
			cmd		:"",
			ptr		:0,
			iRow		:0,
			iDelayMul	:1,
			iDelayDiv	:1,
			tmp	:{
				iNumerator	:-1,
				iDenominator	:-1
			},
			log	:{
				args: [],
				text: ""
			}
		};
	}
	ShowLEDs(LEDs);
	url = window.location.href.split("?");
	if(url.length > 1) {
		url.pop().split("&")
		.forEach(function(str) {
			str = str.split("=");
			switch(str[0]) {
			case "script":
				document.getElementById("Scenario").value = unescape(str[1].replace(/%25u/g, "%u"));
				break;
			}
			return true;
		});
		url = url.join("?");
	} else
		url = window.location.href;
}
</script>
</head>
<body onload='main()'>
<table>
<tr valign=top>
<td colspan=2><pre id=leds></pre><a href='' id=Progress title='Click for share'>Progress - 0%</a></td></tr>
<tr><td>
<textarea id='Scenario' rows=25 cols=80>
Glazeur-scenario
&sect;1 &#x33B3;&#x21E5;	Paragraph #1
&#x21E5;	

&#x21E5;	Main paragraph
Hello world!
&#x21E5;	1000&#x33B3;100&#x3390;
&#x21E5;	1524&#x2328;1&#x2328;
&#x21E5;	&#x2399;&#x23F1;&#x239A;&#x23F1;</textarea></td>
<td valign='top'><table id='Brailles'></table>
<table id='Numbers'></table>
<table id='Operators'></table>
<table id='Effects'></table></td></tr></table>
<button onclick='document.getElementById("Progress").href=url+"?script="+escape(document.getElementById("Scenario").value).replace(/%u/g, "%25u"); parse(LEDs, document.getElementById("Scenario").value)'>Compile Glazeur-scenario</button>
<p style=text-align:center><a href='http://github.com/Alikberov'>Visit me now</a><br />&copy;2017 Alikberov</p>
</body>
