<!doctype html>
<html itemscope='' itemtype='http://schema.org/SearchResultsPage' lang='ru'		  >
<head											  >
<meta content='text/html; charset=windows-1251'		http-equiv='Content-Type'	 />
<meta content='ru-RU'					http-equiv='Content-Language'	 />
<meta content='keyboard,illumination,led,leds,effect,effects,fx,braile'	name='keywords'	 />
<meta content='Static'							name='googlebot' />
<meta content='NoIndex,NoArchive'					name='Robots'	 />
<meta content='http://github.com/Alikberov'				name='Author'	 />
<meta description='Glazeur-Scenarist'							 />
<!--meta http-equiv=refresh content='300'>						-->
<title>Glazeur-scripting</title>
<style>
a	{
	border		:blue thin outset;
}
pre#leds{
	background-color:grey;
}
td.operator	{
	border		:white thin outset;
	cursor		:pointer;
	font-family	:"Segoe UI Emoji";
	font-size	:28px;
}
td.switch_1	{
	background-color:yellow;
	border		:white thin outset;
	cursor		:pointer;
	font-family	:"Segoe UI Emoji";
	font-size	:28px;
}
td.switch_2	{
	background-color:cyan;
	border		:white thin outset;
	cursor		:pointer;
	font-family	:"Segoe UI Emoji";
	font-size	:28px;
}
td.switch_3	{
	background-color:magenta;
	border		:white thin outset;
	cursor		:pointer;
	font-family	:"Segoe UI Emoji";
	font-size	:28px;
}
textarea{
	font-family	:"Courier New";
	font-size	:18px;
}
</style>
<script>//Symbol";
function	WCHAR(str) {
	var
		ptr	= 0,
		string	= str;
	return {
		set ptr(seek)	{	// seek to position
			ptr = seek;
		},
		set concat(str)	{
			string += str;
		},
		get ptr()	{	// get the position
			return ptr;
		},
		get str()	{	// get string by position
			return string.substr(ptr);
		},
		get c_ptr()	{	// char by pointer
			return string.charAt(ptr);
		},
		get a_ptr()	{	// ascii by pointer
			return string.charCodeAt(ptr);
		},
		get arr_ptr()	{	// ascii by pointer
			return [string.charCodeAt(ptr), string.charCodeAt(ptr + 1)];
		},
		get c_ptr_pp()	{	// char by pointer with post-increment
			return string.charAt(ptr ++);
		},
		get a_ptr_pp()	{	// ascii by pointer with post-increment
			return string.charCodeAt(ptr ++);
		},
		get c_pp_ptr()	{	// char by pointer with pre-increment
			return string.charAt(++ ptr);
		},
		get a_pp_ptr()	{	// ascii by pointer with pre-increment
			return string.charCodeAt(++ ptr);
		}
	};
}
////////////////////////////////////////////////////////////////////////////////
var	LEDs	= {
		leds			:[0,0,0,0,0,0,0,0,0,0],
		movie			:[],
		order			:0,
		speed			:100,
		iDelay			:100,
		iKeyboard		:0,
		tmp	: {
			iNumerator	:0,
			iDenominator	:0,
			pReps		:[],	// Pointers of Repeats(...)
			nReps		:[],	// Numerators of Repeats(...)
			dReps		:[],	// Donominators of Repeats(...)
			pRems		:[],	// Pointers for Remarks
			pDots		:[],	// Pointers for Dots
			pRem		:"",	// Current Remark
			pDot		:""	// Current Dots
			},
		Scenario		:"",
		Sections		:[],
		Measures		:[],
		iMeasure		:-1,
		ptr			:0,
		iRow			:0,
		log	: {
			text		:"",
			Measures	:[]
		}
	};
var	url;
var	hTimer, hEraser;
var	hTabs		= [];
var	iTabs		= 0;
var	iEstimated	= 1,
	iDuration	= 1;
////////////////////////////////
var
	VK = {
		BACK_SPACE	:0x08,
		TAB		:0x09,
		RETURN		:0x0D,
		BREAK		:0x13,
		CAPITAL		:0x14,
		ESC		:0x1B,
		PREV		:0x21,
		NEXT		:0x22,
		END		:0x23,
		HOME		:0x24,
		LEFT		:0x25,
		UP		:0x26,
		RIGHT		:0x27,
		DOWN		:0X28,
		PRINT		:0x2C,
		INSERT		:0x2D,
		DELETE		:0x2E,
		CONTEXT		:0x5D,
		NUMPAD0		:0x60,
		NUMPAD1		:0x61,
		NUMPAD2		:0x62,
		NUMPAD3		:0x63,
		NUMPAD4		:0x64,
		NUMPAD5		:0x65,
		NUMPAD6		:0x66,
		NUMPAD7		:0x67,
		NUMPAD8		:0x68,
		NUMPAD9		:0x69,
		F1		:0x70,
		F2		:0x71,
		F3		:0x72,
		F4		:0x73,
		F5		:0x74,
		F6		:0x75,
		F7		:0x76,	// Assembly
		F8		:0x77,
		F9		:0x78,	// Break point on/off
		F10		:0x79,
		F11		:0x7A,
		F12		:0x7B,
		BROWSE_BACK	:0xA6,
		BROWSE_FORWARD	:0xA7,
		BROWSE_REFRESH	:0xA8,
		BROWSE_STOP	:0xA9,
		BROWSE_SEARCH	:0xAA,
		BROWSE_HOME	:0xAC,
		PLAYER_FORWARD	:0xB0,	// Emulation IP ++
		PLAYER_REWIND	:0xB1,	// Emulation IP --
		PLAYER_STOP	:0xB2,	// Emulation stop/step
		PLAYER_PLAY	:0xB3,	// Emulation stop/start
		BROWSE_MAIL	:0xB4
	};
////////////////////////////////
///////	Glazeurs Using Ignores
var	GUI_TABULATION	=0x0009;	// [->]	Tabulation key
var	GUI_TABULATIONS	=0x2409;	// [HT]	Tabulation signature
var	GUI_TABULATIONG	=0x21E5;	// ->|	Tabulation glyph
////////////////////////////////
///////	Glazeur Usings Indexators
var	GUI_SUPER_ZERO	=0x2070;	// ^0^	Superscript index 0
var	GUI_SUPER_ONE	=0x00B9;	// ^1^	Superscript index 1
var	GUI_SUPER_TWO	=0x00B2;	// ^2^	Superscript index 2
var	GUI_SUPER_THREE	=0x00B3;	// ^3^	Superscript index 3
var	GUI_SUPER_FOUR	=0x2074;	// ^4^	Superscript index 4
var	GUI_SUPER_NINE	=0x2079;	// ^9^	Superscript index 9
var	GUI_LOWER_ZERO	=0x2080;	// _0_	Subscript index 0
var	GUI_LOWER_NINE	=0x2089;	// _9_	Subscript index 9
var	GUI_DOTTED_TAG	=0x2488;	//  1.	Dotted number 1.
var	GUI_DOTTED_TOP	=0x249B;	//	20.	Dotted number 20.
var	GUI_CIRCLE_TAG	=0x2460;	// (1)	Circled number 1
var	GUI_CIRCLE_TOP	=0x2473;	// (20)	Circled number 20
var	GUI_CIRCLE_KEY	=0x24B6;	// (A)	Circled key A
var	GUI_CIRCLE_ZED	=0x24CF;	// (Z)	Circled key Z
var	GUI_DOT_PATTERN	=0x2800;	// :::	Braille pattern
////////////////////////////////
///////	Glazeur Execution Markup
var	GEM_SECTION	=0x00A7;	//	§	Section
var	GEM_MEASURE_SET	=0x20E3;	// [ ]	Set measure
var	GEM_FADE_IN	=0x21E1;	// /|\	Fade in effect
var	GEM_FADE_OUT	=0x21E3;	// \|/	Fade out effect
var	GEM_FADE_AND	=0x2227;	// /\	Fade AND effect
var	GEM_FADE_OR	=0x2228;	// \/	Fade OR effect
var	GEM_FADE_XOR	=0x2295;	// (+)	Fade XOR effect
var	GEM_FADE_LO	=0x270E;	// ^\	Lower bright  - 10%
var	GEM_FADE_MID	=0x270F;	// --	Middle bright - 50%
var	GEM_FADE_HI	=0x2710;	// _/	High bright   - 90%
var	GEM_DEVICE_SET	=0x2328;	// [:]	Keyboard select
var	GEM_STATE_LOAD	=0x2397;	// [[]	Load state
var	GEM_STATE_SAVE	=0x2398;	// []]	Save state
var	GEM_STATE_NULL	=0x239A;	// [/]	Clear state
var	GEM_SHOW_DELAY	=0x23F1;	// (^)	Show delay pause
var	GEM_SHOW_SPEED	=0x23F2;	// (-)	Show speed
var	GEM_LOOP_TIMES	=0x267B;	// /_\	Looping for n-times
var	GEM_SHOW_ALERT	=0x26A0;	// /!\	Alert
var	GEM_STATE_STOP	=0x26D4;	// (=)	Stop/Halt
var	GEM_SECTION_UP	=0x2934;	// /\	Measure prev. line
var	GEM_SECTION_DWN	=0x2935;	// \/	Measure next line
var	GEM_SECTION_RUN	=0x27B0;	// _o_	Measure line run
////////
var	GEM_RUN_UP	=0x25B2;	// [^]	Run LEDs to up
var	GEM_RUN_RIGHT	=0x25B6;	// [>]	Run LEDs to right
var	GEM_RUN_DOWN	=0x25BC;	// [v]	Run LEDs to down
var	GEM_RUN_LEFT	=0x25C0;	// [<]	Run LEDs to left
////////
var	GEM_STATE_PRINT	=0x2399;	// [~]	Print the status
var	GEM_SETUP_HZ	=0x3390;	// Hz	Refreshing frequency for LEDs
var	GEM_SETUP_MS	=0x33B3;	// ms	Animation delay
////////////////////////////////
///////	Glazeur Enhanced Token
function GET_KEY(wc)	{return (GUI_CIRCLE_TAG <= (wc) && (wc) <= GUI_CIRCLE_TOP ? (wc) - GUI_CIRCLE_TAG + 1 : GUI_CIRCLE_KEY <= (wc) && (wc) <= GUI_CIRCLE_ZED ? (wc) - GUI_CIRCLE_KEY + 21 : -1)}
function GET_TAB(wc)	{return (GUI_TABULATION == (wc) || GUI_TABULATIONG == (wc) || GUI_TABULATIONS == (wc))}
function GET_TAG(wc)	{return (GUI_DOTTED_TAG <= (wc) && (wc) <= GUI_DOTTED_TOP ? (wc) - GUI_DOTTED_TAG + 1 : -1)}
function GET_LED(wc)	{return (GUI_DOT_PATTERN == ((wc) & ~255))}
function GET_SUB(wc)	{return (GUI_LOWER_ZERO <= (wc) && (wc) <= GUI_LOWER_NINE ? (wc) - GUI_LOWER_ZERO : -1)}
function GET_PWR(wc)	{return ((GUI_SUPER_FOUR <= (wc) && (wc) <= GUI_SUPER_NINE) || (wc) == GUI_SUPER_ZERO ? (wc) - GUI_SUPER_ZERO : GUI_SUPER_ONE == (wc) ? 1 : GUI_SUPER_TWO == (wc) ? 2 : GUI_SUPER_THREE == (wc) ? 3 : -1)}
////////////////////////////////

function	ShowLevel(bits) {
	var	level = 0;
	for(bits &= 001111111111; bits > 0; bits >>= 3)
		level += bits & 1;
	return 0x191919*0+0x061903 * level;
}
///////////////////////////////

function	ShowLEDs(p, q) {
	var	html = "", i, ds;
	if(!q)
		q = {
			measure: {index: -1, row: -1},
			row: -1,
			leds: p.leds,
			text: ""
		};
	for(i = 0; i < 27; ++ i) {
		html += "<span style=color:#" + ("00000" + Number(ShowLevel(q.leds[i % 9 + 1] >> (i / 9 & 3))).toString(16)).substr(-6) + ">&#x25CF;&nbsp;</span>";
		switch(i) {
		case 8:
			ds = (Math.floor(iDuration / 3600000) % 24) + ":" + ("0" + (Math.floor(iDuration / 60000) % 60)).substr(-2) + ":" + ("0" + (Math.floor(iDuration / 1000) % 60)).substr(-2) + "." + ("00" + (iDuration % 1000)).substr(-3);
			html += "<span style=color:yellow>[" + ds + "]</span><br />";
			break;
		case 17:
			if(p.Scenario.jSection < 0)
				html += "<span style=color:yellow>Scenario-row#" + p.Scenario.iRow + " " + Math.floor(p.Scenario.iLoop * 100 / p.Scenario.iLoops) + "x" + p.Scenario.iLoop + "</span><br />";
			else
				html += "<span style=color:yellow>Scenario-row#" + p.Scenario.iRow + " " + Math.floor(p.Scenario.iLoop * 100 / p.Scenario.iLoops) + "x" + p.Scenario.iLoop + " "
					+ p.Sections[p.Scenario.jSection].iRow + "$" + p.Scenario.jSection + " " + Math.floor(p.Sections[p.Scenario.jSection].iLoop * 100 / p.Sections[p.Scenario.jSection].iLoops) + "x" + p.Sections[p.Scenario.jSection].iLoop + "</span><br />";
				//html += "<span style=color:yellow>Scenario" + (q.row >= 0 ? "-row#" + q.row + (q.measure.index >= 0 ? " " + q.measure.row + "&#167;" + q.measure.index + "(...)" : "") : " halted...") + "</span><br />";
			break;
		case 26:
			html += "<span style=color:yellow>Logging:" + q.text + "</span>";
			break;
		}
	}
	document.getElementById("leds").innerHTML = html;
}

function parse_fraction(pks, pwc) {
	var	iFractions = [
		0x2152010A,	//	1/10 .1
		0x21510109,	//	1/9	0.111
		0x215B0108,	//	1/8	0.125
		0x21500107,	//	1/7	0.143
		0x21590106,	//	1/6	0.167
		0x21550105,	//	1/5	0.2
		0x00BC0104,	//	1/4	0.25
		0x21530103,	//	1/3	0.333
		0x215C0308,	//	3/8	0.375
		0x21560205,	//	2/5	0.4
		0x00BD0102,	//	1/2	0.5
		0x21570305,	//	3/5	0.6
		0x215D0508,	//	5/8	0.625
		0x21540203,	//	2/3	0.667
		0x00BE0304,	//	3/4	0.75
		0x21580405,	//	4/5	0.8
		0x215A0506,	//	5/6	0.833
		0x215E0708,	//	7/8	0.875
		0x21890003	//	0/3
	],	i, wcode;
	if(pwc.c_ptr > '0' && pwc.c_ptr <= '9') {
		pks.iNumerator = 0;
		while(pwc.c_ptr >= '0' && pwc.c_ptr <= '9')
			pks.iNumerator = pks.iNumerator * 10 + +pwc.c_ptr_pp;
	} else
	if(pwc.c_ptr == '0') {
		pks.iNumerator = 0;
		while(pwc.c_ptr >= '0' && pwc.c_ptr <= '7')
			pks.iNumerator = pks.iNumerator * 8 + +pwc.c_ptr_pp;
	} else
		pks.iNumerator = -1;
	pks.iDenominator = -1;
	wcode = pwc.a_ptr;
	i = 10000;
	if(pks.iNumerator > 0)
		switch(wcode) {
		case 0x25:	i /= 10;
		case 0x2030:	i /= 10;
		case 0x2031:	pks.iDenominator = i;
				pwc.ptr ++;
				return pks;
		}		
	do {
		i = iFractions.length;
		while(i --) {
			n = iFractions[i];
			if(n >> 16 == wcode) {
				if(pks.iNumerator < 1)
					pks.iNumerator = (n >> 8) & 255;
				else
				if(pks.iDenominator < 1)
					pks.iNumerator = pks.iNumerator * (n & 255) + ((n >> 8) & 255);
				else
					pks.iNumerator *= (n >> 8) & 255;
				if(pks.iDenominator < 1)
					pks.iDenominator = n & 255;
				else
					pks.iDenominator *= n & 255;
				for(i = 2; pks.iNumerator / i >= 1 && pks.iDenominator / i >= 1; ++ i) {
					if(pks.iNumerator == Math.floor(pks.iNumerator / i) * i && pks.iDenominator == Math.floor(pks.iDenominator / i) * i)
						pks.iNumerator /= i,
						pks.iDenominator /= i,
						i = 1;
				}
				wcode = pwc.a_pp_ptr;
				break;
			}
		}
	} while(i >= 0);	//console.log("(" + p.tmp.iNumerator + "/" + p.tmp.iDenominator + ") == " + Math.floor(p.tmp.iNumerator / p.tmp.iDenominator) + "(" + (p.tmp.iNumerator % p.tmp.iDenominator) + "/" + p.tmp.iDenominator + ")");
	return pks;
}

////////////////////////////////////////////////////////////////////////////////

function play_effect(p, pks, pwc) {
	var	mode = 0,
		code,
		dots = -1,
		index;
	var	lo, hi, base = 001111111111;;
	//
	switch(pwc.a_ptr) {
	case GEM_FADE_IN:
	case GEM_FADE_OUT:
	case GEM_FADE_AND:
	case GEM_FADE_OR:
	case GEM_FADE_XOR:
		mode = pwc.a_ptr_pp;
	}
	switch(pwc.a_ptr) {
	case GEM_FADE_LO:
		base >>= 3 * 4;
	case GEM_FADE_MID:
		base >>= 3 * 4;
	case GEM_FADE_HI:
		base >>= 3 * 1;
		++ pwc;
	}
	code = pwc.a_ptr;
	if(code >= 0x2800 && code <= 0x28FF) {
		index = pks.iKeyboard;
		dots = pks.iNumerator;
		while(code >= 0x2800 && code <= 0x28FF) {
			if(code == 0x28C0) {
				if(dots >= 1 && dots <= pks.pDots.length)
					pks.pDots[0] = pks.pDots[dots - 1],
					dots = -1;
				code = pks.pDots[0].charCodeAt(0);
				pks.pDots[0] = pks.pDots[0].substr(1);
			}
			code &= 255;
			switch(mode) {
			case GEM_FADE_IN:
				lo = base * (code & 7),
				hi = base * ((code >> 3) & 7);
				if((code & 0100) == 0)
					p.leds[index] = (p.leds[index] & ~lo) | ((p.leds[index] << 3) & lo) | (p.leds[index] & lo);
				index = index % 9 + 1;
				if((code & 0200) == 0)
					p.leds[index] = (p.leds[index] & ~hi) | ((p.leds[index] << 3) & hi) | (p.leds[index] & hi);
				index = index % 9 + 1;
				break;
			case GEM_FADE_OUT:
				lo = (base & ~7) * (code & 7),
				hi = (base & ~7) * ((code >> 3) & 7);
				if((code & 0100) == 0)
					p.leds[index] = (p.leds[index] & ~lo) | ((p.leds[index] & lo) >> 3);
				index = index % 9 + 1;
				if((code & 0200) == 0)
					p.leds[index] = (p.leds[index] & ~hi) | ((p.leds[index] & hi) >> 3);
				index = index % 9 + 1;
				break;
			case GEM_FADE_AND:
				lo = base * (code & 7),
				hi = base * ((code >> 3) & 7);
				if((code & 0100) == 0)
					p.leds[index] &= (p.leds[index] & 030000000000) | lo;
				index = index % 9 + 1;
				if((code & 0200) == 0)
					p.leds[index] &= (p.leds[index] & 030000000000) | hi;
				index = index % 9 + 1;
				continue;
			case GEM_FADE_OR:
				lo = base * (code & 7),
				hi = base * ((code >> 3) & 7);
				if((code & 0100) == 0)
					p.leds[index] = (p.leds[index] & 037777777777) | lo;
				index = index % 9 + 1;
				if((code & 0200) == 0)
					p.leds[index] = (p.leds[index] & 037777777777) | hi;
				index = index % 9 + 1;
				continue;
			case GEM_FADE_XOR:
				lo = base * (code & 7),
				hi = base * ((code >> 3) & 7);
				if((code & 0100) == 0)
					p.leds[index] = (p.leds[index] & 037777777777) ^ lo;
				index = index % 9 + 1;
				if((code & 0200) == 0)
					p.leds[index] = (p.leds[index] & 037777777777) ^ hi;
				index = index % 9 + 1;
				continue;
			default:
				lo = base * (code & 7),
				hi = base * ((code >> 3) & 7);
				if((code & 0100) == 0)
					p.leds[index] = (p.leds[index] & 030000000000) | lo;
				index = index % 9 + 1;
				if((code & 0200) == 0)
					p.leds[index] = (p.leds[index] & 030000000000) | hi;
				index = index % 9 + 1;
				break;
			}
			code = pwc.a_pp_ptr;
		}
		return true;
	}
	if(GEM_DEVICE_SET == code && pks.iDenominator < 0) {
		if(pks.iNumerator >= 1 && pks.iNumerator <= 9)
			pks.iKeyboard = pks.iNumerator;
		else
		if(pks.iNumerator >= 1 && pks.iNumerator >= 11)
			p.order = pks.iNumerator;
		else
		if(pks.iNumerator < 0 && mode == GEM_FADE_IN)
			p.iKeyboard = p.iKeyboard % 9 + 1;
		else
		if(pks.iNumerator < 0 && mode == GEM_FADE_OUT)
			pks.iKeyboard = (pks.iKeyboard + 7) % 9 + 1;
		pwc.ptr ++;
		return true;
	}
	if(GEM_RUN_UP == code && pks.iNumerator < 0) {
		pwc.ptr ++;
		for(index = 1; index <= 9; ++ index) {
			code = p.leds[index];
			p.leds[index] = (code & 030000000000) | ((code & 006666666666) >> 1) | ((code & 001111111111) << 2);
		}
		return true;
	}
	if(GEM_RUN_RIGHT == code && pks.iNumerator < 0) {
		pwc.ptr ++;
		index = 9;
		code = p.leds[index];
		while(index > 1)
			p.leds[index] = p.leds[index - 1],
			index --;
		p.leds[index] = code;
		return true;
	}
	if(GEM_RUN_DOWN == code && pks.iNumerator < 0) {
		pwc.ptr ++;
		for(index = 1; index <= 9; ++ index) {
			code = p.leds[index];
			p.leds[index] = (code & 030000000000) | ((code & 004444444444) >> 2) | ((code & 003333333333) << 1);
		}
		return true;
	}
	if(GEM_RUN_LEFT == code && pks.iNumerator < 0) {
		pwc.ptr ++;
		index = 1;
		code = p.leds[index];
		while(index < 9)
			p.leds[index] = p.leds[index + 1],
			index ++;
		p.leds[index] = code;
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////
//	FUNCTION:	Get measure row
//	PURPOSE:	Find the target row
//	Example:
//	|This is measure's commentary
//	|	[1]		This is row #1
//	|This is measure's commentary #2	
//	|	[2]		This is row #2
//	|This is measure's finish
//	|
////////////////////////////////////////////////////////////////////////////////
function parse_section_rows(pks, pwc, iRow) {
	var	rows	= 0;
	var	index;
	//
	do {
		if(pwc.a_ptr < ' ' && !GET_TAB(pwc.a_ptr))
			return -1;
		if(GET_KEY(pwc.a_ptr) > 0)
			++ pwc.ptr;
		index = GET_TAG(pwc.a_ptr);
		if(index > 0)
			++ pwc.ptr;
		else
			index = 0;
		if(GET_LED(pwc.a_ptr)) {
			if(0x28C0 == pwc.a_ptr)
				++ pwc.ptr;
			pks.pDots[index] = pwc.str,
			pks.pDots[0] = pwc.str;
		} else
		if(GET_TAB(pwc.a_ptr))
			pks.iTags[index] = rows,
			pks.iTags[0] = rows,
			++ rows,
			-- iRow;
		else
			pks.pRems[index] = pwc.str,
			pks.pRems[0] = pwc.str;
		if(iRow < 0)
			break;
		while(0x000D != pwc.a_ptr && pwc.a_ptr != 0x000A) {
			if(!pwc.a_ptr_pp)
				return -1;
		}
		if((0x000D == pwc.arr_ptr[0] && pwc.arr_ptr[1] == 0x000A)
		|| (0x000A == pwc.arr_ptr[0] && pwc.arr_ptr[1] == 0x000D))
			pwc.ptr += 2;
		else
			pwc.ptr ++;
	} while(iRow >= 0);
	return rows;
}
function Sleep(pk, pks, iSection, iRow, interval) {
	pk.movie.push({
		measure	:{index: iSection, row: iRow},
		delay	:interval,
		leds	:[].concat(pk.leds),
		row	:pks.iRow,
		text	:pk.log.text
	});
}
function parse_section(pk, iSection = -1, ppwc = 0) {
	var	pks = iSection < 0 ? pk.Scenario : pk.Sections[iSection];
	if(!pks.pSection)
		return;
	var	pwc = new WCHAR(pks.pSection.str);
	var	prem = "", plog = "";
	var	jSection;		//	Job-Section index
	var	kSection;		//	Key-Section index
	var	iRow, i, tmp;
	var	iRowIndex, iRowLoops;
	var	index;
	var	nTabs	= 0;
	//
	var	iDelay		= 0;
	//
	if(ppwc)
		++ ppwc.ptr,
		pwc = ppwc;
	else {
		iRow = parse_section_rows(pks, pwc, pks.iRow);
		if(iRow < 0)
			return false;
		while(GET_TAB(pwc.a_ptr))
			++ pwc.ptr;
	}
	iRowIndex = pks.iRow ++;
	iRowLoops = pks.iLoop;
	pks.iLoop = 0;
	pks.iLoops = pks.iLoops > 0 ? pks.iLoops : 1;
	pks.iReps = -1;
	pks.nReps = [];
	pks.dReps = [];
	pks.pReps = [];
	jSection = pks.jSection;
	while(pwc.a_ptr >= 0x20 && !GET_TAB(pwc.a_ptr)) {
		while(pwc.c_ptr == ' ')
			++ pwc.ptr;
		i = GET_TAG(pwc.a_ptr);
		if(i > 0) {
			if(pks.iTags[i] > 0)
				pks.iRow = pks.iTags[i];
			++ pwc.ptr;
			continue;
		}
		i = GET_KEY(pwc.a_ptr);
		if(i > 0) {
			if(pks.iKeys[i] > 0)
				pks.iRow = pks.iKeys[i];
			++ pwc.ptr;
			continue;
		}
		parse_fraction(pks, pwc);
		if(GEM_SECTION == pwc.a_ptr && pks.iDenominator < 0) {
			++ pwc.ptr;
			if('0' <= pwc.c_ptr && pwc.c_ptr <= '9')
				jSection = pwc.a_ptr_pp - 0x0030,
				pks.jSection = jSection;
			else
			if('(' == pwc.c_ptr) {
				parse_section(pk, jSection, pwc);
				continue;
			}
			if(pks.iNumerator >= 0)
				if(iSection < 0)
					pk.Sections[jSection].iRow = pks.iNumerator;
				else
					pks.iRow = pks.iNumerator;
			continue;
		}
		if(GEM_SECTION == pwc.a_ptr && pks.iNumerator >= 0 && pks.iDenominator < 0) {
			if(iSection < 0 && jSection >= 0) {
				pk.Sections[jSection].iRow = pks.iNumerator;
			} else
				pks.iRow = pks.iNumerator;
			++ pwc.ptr;
			continue;
		}
		if(GEM_SECTION_RUN == pwc.a_ptr && pks.iDenominator < 0 && jSection >= 0) {
			pk.Sections[jSection].iKeyboard = pks.iKeyboard;
			parse_section(pk, jSection);
			++ pwc.ptr;
			continue;
		}
		if(GEM_SECTION_UP == pwc.a_ptr && pks.iDenominator < 0) {
			if(pks.iNumerator > 0)
				pks.iRow = pks.iRow > pks.iNumerator ? pks.iRow - pks.iNumerator : 1;
			else
			if(pks.iRow > 1)
				-- pks.iRow;
			++ pwc.ptr;
			continue;
		}
		if(GEM_SECTION_DWN == pwc.a_ptr && pks.iDenominator < 0) {
			if(pks.iNumerator > 0)
				pks.iRow += pks.iNumerator;
			else
				++ pks.iRow;
			++ pwc.ptr;
			continue;
		}
		if(GEM_SHOW_DELAY == pwc.a_ptr) {
			if(jSection < 0)
				;//wprintf(L"Scenario-row#%-3d x%d", pk->Scenario.iRow, pk->Scenario.iLoop);
			else
				;//wprintf(L"Scenario-row#%-3d x%d %3d$%d x%d", pk->Scenario.iRow, pk->Scenario.iLoop, pk->Sections[jSection].iRow, jSection, iRowLoops);
			if(pks.iNumerator < 0) {
				if(pks.iDelayDivider > 0) {
					pk.duration += pks.iDelayPeriod * pks.iDelayMultiplier / pks.iDelayDivider;
					Sleep(pk, pks, iSection, iRow, pks.iDelayPeriod * pks.iDelayMultiplier / pks.iDelayDivider);
				} else {
					if(iSection < 0)
						;//printf("\r\nERROR: Scenario Row %d --- Wrong Delay Interval", iRow);
					else
						;//printf("\r\nERROR: Paragraph #%d Row %d --- Wrong Delay Interval", iSection, iRow);
					Sleep(pk, pks, iSection, iRow, 1000);
				}
			} else
			if(pks.iDenominator < 0)
				pk.duration += pks.iDelayPeriod * pks.iDelayMultiplier * pks.iNumerator / pks.iDelayDivider,
				Sleep(pk, pks, iSection, iRow, pks.iDelayPeriod * pks.iDelayMultiplier * pks.iNumerator / pks.iDelayDivider);
			else
				pk.duration += pks.iDelayPeriod * pks.iDelayMultiplier * pks.iNumerator / pks.iDelayDivider / pks.iDenominator,
				Sleep(pk, pks, iSection, iRow, pks.iDelayPeriod * pks.iDelayMultiplier * pks.iNumerator / pks.iDelayDivider / pks.iDenominator);
/*			if(pks->iNumerator < 0 && pks->iDenominator < 0) {
				if(pks->iDelayDivider > 0)
					Sleep(pks->iDelayPeriod * pks->iDelayMultiplier / pks->iDelayDivider);
				else {
					printf("\r\nERROR: Paragraph #%d Row %d", iSection, iRow);
					Sleep(5000);
				}
			} else
			if(pks->iNumerator == 0 && pks->iDenominator < 0)
				pks->iDelayMultiplier = pk->Scenario.iDelayPeriod,
				pks->iDelayDivider = 1;
			else {
				if(pks->iNumerator > 0)
					pks->iDelayMultiplier = pks->iNumerator,
					pks->iDelayDivider = 1;
				if(pks->iDenominator > 0)
					pks->iDelayDivider = pks->iDenominator;
			}*/
			//printf("[%d:%02d:%02d.%03d] - I/O-Errors:%d", pk->duration / 3600000 % 10, pk->duration / 60000 % 60, pk->duration / 1000 % 60, pk->duration % 1000, pk->errors);
			++ pwc.ptr;
			continue;
		}
		if(';' == pwc.c_ptr) {
			++ pwc.ptr;
			if(pks.iReps >= 0) {
				i = pks.nReps[pks.iReps];
				if(i > pks.dReps[pks.iReps])
					continue;
				-- pks.nReps[pks.iReps];
				if(i > 1)
					continue;
				i = 0;
				do {
					++ pwc.ptr;
					if('(' == pwc.c_ptr)
						++ i;
					if(')' == pwc.c_ptr)
						-- i;
				} while(pwc.a_ptr && i >= 0);
			}
		}
		if(')' == pwc.c_ptr) {
			if(!!ppwc)
				return ppwc.ptr = ++ pwc.ptr;
				//return !!*(*ppwc = ++ pwc);
			if(pks.iReps >= 0) {
				i = pks.dReps[pks.iReps];
				if(i > 0) {
					if((pks.nReps[pks.iReps] -= i) > 0) {
						pwc = pks.pReps[pks.iReps];
						continue;
					}
				} else
				if(-- pks.nReps[pks.iReps] > 0) {
					pwc = pks.pReps[pks.iReps];
					continue;
				}
				-- pks.iReps;
			}
			++ pwc.ptr;
			continue;
		}
		if('(' == pwc.c_ptr) {
			++ pwc.ptr;
			if(pks.iNumerator > 0) {
				++ pks.iReps;
				pks.pReps[pks.iReps] = pwc.ptr;
				pks.nReps[pks.iReps] = pks.iNumerator;
				pks.dReps[pks.iReps] = pks.iDenominator;
				continue;
			}
			break;
		}
		if(play_effect(pk, pks, pwc))
			continue;
		if(GEM_STATE_PRINT == pwc.a_ptr) {
			++ pwc.ptr;
			if(pks.iNumerator >= 0 && pks.iNumerator <= 20)
				index = pks.iNumerator;
			else
				index = 0;
			prem = pks.pRems[index];
			plog = pk.log;
			i = 0;
/*			while(*prem && *prem != 0x000D) {
				index = GET_SUB(*prem);
				kSection = -1;
				if(index >= 0)
					kSection = iSection;
				else
					index = GET_PWR(*prem);
				if(index >= 0) {
					if(index == 0)
						index = pk->Sections[kSection].iRow;
					else
					if(index - 1 <= pk->Sections[kSection].iReps) {
						tmp = pk->Sections[kSection].dReps[pk->Sections[kSection].iReps - index + 1];
						index = pk->Sections[kSection].nReps[pk->Sections[kSection].iReps - index + 1];
						if(tmp > 0)
							index /= tmp;
					} else
						index = -1;
					if(index >= 0)
						index = swprintf(plog, L"%d", index);
					else
						index = swprintf(plog, L"?");
					plog += index;
					i += index;
					++ prem;
					continue;
				}
				if(GEM_SECTION == *prem)
					*plog ++ = iSection + '0',
					++ prem;
				else
					*plog ++ = *prem ++;
				++ i;
			}
			WriteConsoleW(hStdOut, pk->log, i, NULL, NULL);*/
			continue;
		}
		if(GEM_STATE_NULL == pwc.a_ptr) {
			if(pks.iDenominator < 0 && pks.iNumerator < 0) {
			} else
			if(pks.iDenominator < 0) {
				if(pks.iNumerator >= 1 && pks.iNumerator <= 20) {
					if(pks.pDots[pks.iNumerator])
						pks.pDots[0] = pks.pDots[pks.iNumerator];
				}
			}
			++ pwc;
			continue;
		}
		if(GEM_DEVICE_SET == pwc.a_ptr && pks.iDenominator < 0) {
			if(pks.iNumerator >= 1 && pks.iNumerator <= 9)
				pks.iKeyboard = pks.iNumerator;
			else
			if(pks.iNumerator >= 1 && pks.iNumerator >= 11) {
				index = pks.iNumerator;
				pk.order = 0;
				do
					pk.order = pk.order * 10 + index % 10;
				while((index /= 10) >= 1);
			}
			pwc.ptr ++;
			continue;
		}
		if(GEM_SHOW_SPEED == pwc.a_ptr) {
			if(pks.iNumerator < 0)
				pks.iDelayMultiplier = 1,
				pks.iDelayDivider = 1;
			else
			if(pks.iDenominator < 0)
				pks.iDelayMultiplier = 1,
				pks.iDelayDivider = 1;
			else
				pks.iDelayMultiplier *= pks.iNumerator,
				pks.iDelayDivider *= pks.iDenominator;
			//parse_fraction(pks->iDelayMultiplier, pks->iDelayDivider);
			if(pks.iNumerator < 0 && pks.iDenominator < 0) {
				if(pks.iDelayDivider > 0)
					Sleep(pk, pks, iSection, iRow, pks.iDelayPeriod * pks.iDelayMultiplier / pks.iDelayDivider);
//				else {
//					printf("\r\nERROR: Paragraph #%d Row %d", iSection, iRow);
//					Sleep(5000);
//				}
			} else
			if(pks.iNumerator == 0 && pks.iDenominator < 0)
				pks.iDelayMultiplier = pks.Scenario.iDelayPeriod,
				pks.iDelayDivider = 1;
			else {
				if(pks.iNumerator > 0)
					pks.iDelayMultiplier = pks.iNumerator,
					pks.iDelayDivider = 1;
				if(pks.iDenominator > 0)
					pks.iDelayDivider = pks.iDenominator;
			}
			++ pwc.ptr;
			continue;
		}
		if(GEM_LOOP_TIMES == pwc.a_ptr) {
			++ pwc.ptr;
			if(pks.iNumerator > 0 && pks.iDenominator < 0) {
				if(pks.iNumerator > iRowLoops)
					pks.iRow = iRowIndex,
					pks.iLoop = iRowLoops + 1,
					pks.iLoops = pks.iNumerator;
			}
			continue;
		}
		if(GEM_SETUP_MS == pwc.a_ptr) {
			++ pwc.ptr;
			if(iSection < 0) {
				if(pks.iNumerator > 0 && pks.iDenominator > 0)
					pks.iDelayMultiplier = pks.iNumerator,
					pks.iDelayDivider = pks.iDenominator;
				else
				if(pks.iNumerator > 0)
					pks.iDelayPeriod = pks.iNumerator,
					pks.iDelayMultiplier = 1,
					pks.iDelayDivider = 1;
				else
					pks.iDelayMultiplier = 1,
					pks.iDelayDivider = 1;
				continue;
			} else
			if(pks.iNumerator > 0 && pks.iDenominator > 0)
				pks.iDelayMultiplier = pks.iNumerator,
				pks.iDelayDivider = pks.iDenominator;
			else
			if(pks.iNumerator > 0)
				pks.iDelayPeriod = pks.iNumerator,
				pks.iDelayMultiplier = 1,
				pks.iDelayDivider = 1;
			else
				pks.iDelayPeriod = pk.Scenario.iDelayPeriod * pk.Scenario.iDelayMultiplier / pk.Scenario.iDelayDivider,
				pks.iDelayMultiplier = 1,
				pks.iDelayDivider = 1;
			continue;
		}
		if(GEM_SETUP_HZ == pwc.a_ptr && pks.iNumerator >= 0 && pks.iDenominator < 0) {
			pk.speed = pks.iNumerator;
			++ pwc.ptr;
			continue;
		}
		++ pwc.ptr;
	};
	return true;
}

function	animate() {
	var	q = LEDs.movie.shift(), hPrg = document.getElementById("Progress");
	if(q) {
		var	i, sPrg, iPrg;
		ShowLEDs(LEDs, q);
		hTimer = setTimeout("animate()", q.delay);
		iPrg = Math.floor(iDuration * 100 / iEstimated);
		sPrg = "";
		for(i = 0; i < iPrg; i += 2)
			sPrg += "\u2593";
		sPrg += i == iPrg ? "\u2593" : "\u2592";
		while(i < 100)
			sPrg += "\u2591",
			i += 2;
		hPrg.textContent = sPrg;
		iDuration += q.delay;
	} else
	if(iEstimated > 1) {
		hPrg.textContent = "Completed! Click for share this scenario.";
		ShowLEDs(LEDs);
	}
}

function parse_scenario(pk, cmd) {
	var	pwc = new WCHAR(cmd);
	var	pks;
	var	iSection;
	var	index, iRow;
	var	wide, size;
	//
	do {
		iRow = 0;
		wide = pwc.arr_ptr;
		if(GEM_SECTION == wide[0] && 0x0030 <= wide[1] && wide[1] <= 0x0039)
			iSection = pwc.a_pp_ptr - 0x0030,
			++ pwc.ptr,
			pks = pk.Sections[iSection];
		else
			iSection = -1,
			pks = pk.Scenario;
		pks.iRow = 0;
		pks.pSection = new WCHAR(pwc.str);
		pks.iLoops = 0;
		for(index = 0; index <= 20; ++ index)
			pks.pDots[index] = 0,
			pks.pRems[index] = 0,
			pks.iTags[index] = 0;
		for(index = 0; index <= 46; ++ index)
			pks.iKeys[index] = 0;
		pks.iLoop = 0;
		pks.jSection = -1;
		do {
			if(GEM_SECTION == pwc.a_ptr)
				break;
			size = 0;
			index = GET_KEY(pwc.a_ptr);
			if(index > 0)
					console.log("Key[" + index + "] = iRow#" + iRow),
				pks.iKeys[index] = iRow,
				++ pwc.ptr,
				++ size;
			index = GET_TAG(pwc.a_ptr);
			if(index < 1)
				index = 0;
			else
				++ pwc.ptr,
				++ size;
			if(GET_LED(pwc.a_ptr))
					console.log("Dot[" + index + "] = iRow#" + iRow),
				pks.pDots[index] = pwc.str,
				pks.pDots[0] = pwc.str;
			else
			if(GET_TAB(pwc.a_ptr))
					console.log("Tag[" + index + "] = iRow#" + iRow),
				pks.iTags[index] = iRow,
				pks.iTags[0] = iRow,
				iRow ++;
			else
				pks.pRems[index] = pwc.str,
				pks.pRems[0] = pwc.str;
			while(!!pwc.a_ptr && 0x000D != pwc.a_ptr && pwc.a_ptr != 0x000A)
				++ pwc.ptr,
				++ size;
			wide = pwc.arr_ptr;
			if((0x000D == wide[0] && wide[1] == 0x000A)
			|| (0x000A == wide[0] && wide[1] == 0x000D)) {
				if(size == 0)
					pwc.ptr ++,
					pwc.ptr ++;
				else
					pwc.ptr += 2;
			} else
			if(0x000D == wide[0] || wide[0] == 0x000A) {
				if(size == 0)
					pwc.ptr += 1;
				else
					++ pwc.ptr;
			}
		} while(size > 0);
	} while(!!pwc.a_ptr && (iSection >= 0 || GEM_SECTION == pwc.a_ptr));
}

function	animate_section() {
	var	q, i,
		hPrg = document.getElementById("Progress"),
		hMode = document.getElementById("Mode");
	q = LEDs.movie.shift();
	if(!q)
		ShowLEDs(LEDs),
		parse_section(LEDs);
	q = LEDs.movie.shift();
	if(!q)
		hTimer = setTimeout(animate_section, 1);
	if(q) {
		var	i, sPrg, iPrg;
		ShowLEDs(LEDs, q);
		hTimer = setTimeout(animate_section, q.delay);
		iPrg = Math.floor(iDuration * 100 / iEstimated);
		sPrg = "";
		/*for(i = 0; i < iPrg; i += 2)
			sPrg += "\u2593";
		sPrg += i == iPrg ? "\u2593" : "\u2592";
		while(i < 100)
			sPrg += "\u2591",
			i += 2;
		hPrg.textContent = sPrg;*/
		iDuration += q.delay;
	} else
	if(iEstimated > 1) {
		hPrg.textContent = "Completed! Click for share this scenario.";
		ShowLEDs(LEDs);
	}
/*	if(Mode.value != "") {
		i = "1234567890qwertyuiopABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf(Mode.value) + 1;
		Mode.value = "";
		if(i > 0) {
			document.title = i;
			i = LEDs.Scenario.iKeys[i];
			if(i > 0) 
				LEDs.Scenario.iRow = i;
		}
	}*/
}

function	parse(p, cmd) {
	var	wcode,
		ascii,
		tmp;
	//////////////////////////////////////////
	parse_scenario(p, cmd);
	parse_section(p);
	clearTimeout(hTimer);
	animate_section();
	return;
}

function insertAtCursor(hText, szChar) {
    //IE support
	if(document.selection) {
		hText.focus();
		sel = document.selection.createRange();
		sel.text = szChar;
	} else
	//MOZILLA and others
	if(hText.selectionStart || hText.selectionStart == '0') {
		var	startPos	= hText.selectionStart;
		var	endPos		= hText.selectionEnd;
		hText.value = hText.value.substring(0, startPos)
			+ szChar
			+ hText.value.substring(endPos, hText.value.length);
		hText.selectionStart = startPos + szChar.length;
		hText.selectionEnd = hText.selectionStart;
	} else
		hText.value += szChar;
}
function insertOperator(e) {
	if(e.target && (e.target.nodeName == "TD" || e.target.nodeName == "SPAN")) {
		insertAtCursor(document.getElementById("Scenario"), e.target.textContent.replace(/\u23CE\r/g, "\r\n"));
		document.getElementById("Scenario").focus();
	}
}
function hidingTable(e) {
	hEraser = setTimeout(function() {
		hTabs[iTabs].style.display = "none";
		iTabs = 0;
		hTabs[iTabs].style.display = "block";
	}, 500);
}
function holdingTable(e) {
	clearTimeout(hEraser);
	hEraser = 0;
}

function main() {
	var	layouts = [
		[
			"0x00002077:Iteration of basic cycle #7",
			"0x00002078:Iteration of basic cycle #8",
			"0x00002079:Iteration of basic cycle #9",
			"0x00000037:Number @",
			"0x00000038:Number @",
			"0x00000039:Number @",
			"0x00002087:Iteration of current cycle #7",
			"0x00002088:Iteration of current cycle #8",
			"0x00002089:Iteration of current cycle #9",
			"0x00002074:Iteration of basic cycle #4",
			"0x00002075:Iteration of basic cycle #5",
			"0x00002076:Iteration of basic cycle #6",
			"0x00000034:Number @",
			"0x00000035:Number @",
			"0x00000036:Number @",
			"0x00002084:Iteration of current cycle #4",
			"0x00002085:Iteration of current cycle #5",
			"0x00002086:Iteration of current cycle #6",
			"0x000000B9:Iteration of basic cycle #1",
			"0x000000B2:Iteration of basic cycle #2",
			"0x000000B3:Iteration of basic cycle #3",
			"0x00000031:Number @",
			"0x00000032:Number @",
			"0x00000033:Number @",
			"0x00002081:Iteration of current cycle #1",
			"0x00002082:Iteration of current cycle #2",
			"0x00002083:Iteration of current cycle #3",
			"0x00002070:Index of basic row",
			"0x0000239A:Clear status",
			"0x000023F1:Adjust current intervals and wait for interval - \xBD@..999\xBC\xBD@	Reset to default interval - 0@		Wait for interval - @",
			"0x00000030:Number @",
			"0x00000028:Open the bracket			Loop for n-times - 1(...) .. 999(...)",
			"0x00000029:Closing bracket",
			"0x00002080:Index of current row",
			"0x00002399:Show status",
			"0x24090009:Tabulation",
			"0x21E50009:Tabulation",
			"0x0003267D:Special FX				---",
			"0x000023F2:Timing				---",
			"0x000026D4:Halt",
			"0x00022318:Labels",
			"0x000026A0:Alert",
			"0x000027B0:Replay line of paragraph",
			"0x0001283F:Dots",
			"0x23CE000D:Enter",
			"0x0000215E:7/8",
			"0x0000215D:5/8",
			"0x00002157:3/5",
			"0x00A70037:Define/append paragraph #7		Select paragraph #7",
			"0x00A70038:Define/append paragraph #8		Select paragraph #8",
			"0x00A70039:Define/append paragraph #9		Select paragraph #9",
			"0x00002150:1/7",
			"0x0000215B:1/8",
			"0x00002151:1/9",
			"0x000000BE:3/4",
			"0x00002158:4/5",
			"0x0000215A:5/6",
			"0x00A70034:Define/append paragraph #4		Select paragraph #4",
			"0x00A70035:Define/append paragraph #5		Select paragraph #5",
			"0x00A70036:Define/append paragraph #6		Select paragraph #6",
			"0x000000BC:1/4",
			"0x00002155:1/5",
			"0x00002159:1/6",
			"0x00002156:2/5",
			"0x00002154:2/3",
			"0x0000215C:3/8",
			"0x00A70031:Define/append paragraph #1		Select paragraph #1",
			"0x00A70032:Define/append paragraph #2		Select paragraph #2",
			"0x00A70033:Define/append paragraph #3		Select paragraph #3",
			"0x00002152:1/10",
			"0x000000BD:1/2",
			"0x00002153:1/3",
			"0x00000020:",
			"0x00000020:",
			"0x00000020:",
			"0x00A70030:Define/append paragraph #0		Select paragraph #0",
			"0x000000A7:Define/append paragraph - @0 .. @9	Select paragraph - @0 .. @9		Switch to paragraph row - 0@ .. 999@",
			"0x00A70028:Active paragraph settings - @(...)",
			"0x00000025:percent",
			"0x00002030:per mille",
			"0x00002031:per 10 milles"
		],	[
		],	[
			"0x00A70037:Define/append paragraph #7		Select paragraph #7",
			"0x00A70038:Define/append paragraph #8		Select paragraph #8",
			"0x00A70039:Define/append paragraph #9		Select paragraph #9",
			"0x00002498:Sub-label 17",
			"0x00002499:Sub-label 18",
			"0x0000249A:Sub-label 19",
			"0x00000020:",
			"0x00002470:Interactive label 17	Num-pad 7",
			"0x00002471:Interactive label 18	Num-pad 8",
			"0x00002472:Interactive label 19	Num-pad 9",
			"0x00A70034:Define/append paragraph #4		Select paragraph #4",
			"0x00A70035:Define/append paragraph #5		Select paragraph #5",
			"0x00A70036:Define/append paragraph #6		Select paragraph #6",
			"0x00002495:Sub-label 14",
			"0x00002496:Sub-label 15",
			"0x00002497:Sub-label 16",
			"0x00000020:",
			"0x0000246D:Interactive label 14	Num-pad 4",
			"0x0000246E:Interactive label 15	Num-pad 5",
			"0x0000246F:Interactive label 16	Num-pad 6",
			"0x00A70031:Define/append paragraph #1		Select paragraph #1",
			"0x00A70032:Define/append paragraph #2		Select paragraph #2",
			"0x00A70033:Define/append paragraph #3		Select paragraph #3",
			"0x00002492:Sub-label 11",
			"0x00002493:Sub-label 12",
			"0x00002494:Sub-label 13",
			"0x00000020:",
			"0x0000246A:Interactive label 11	Num-pad 1",
			"0x0000246B:Interactive label 12	Num-pad 2",
			"0x0000246C:Interactive label 13	Num-pad 3",
			"0x00A70030:Define/append paragraph #0		Select paragraph #0",
			"0x00000020:",
			"0x00000020:",
			"0x0000249B:Sub-label 20",
			"0x00000020:",
			"0x00000020:",
			"0x00000020:",
			"0x00002473:Interactive label 20	Num-pad 0",
			"0x00000020:",
			"0x00000020:",
			"0x00002488:Sub-label 1",
			"0x00002489:Sub-label 2",
			"0x0000248A:Sub-label 3",
			"0x0000248B:Sub-label 4",
			"0x0000248C:Sub-label 5",
			"0x0000248D:Sub-label 6",
			"0x0000248E:Sub-label 7",
			"0x0000248F:Sub-Label 8",
			"0x00002490:Sub-label 9",
			"0x00002491:Sub-label 10",
			"0x00002460:Interactive label 1		The key 1",
			"0x00002461:Interactive label 2		The key 2",
			"0x00002462:Interactive label 3		The key 3",
			"0x00002463:Interactive label 4		The key 4",
			"0x00002464:Interactive label 5		The key 5",
			"0x00002465:Interactive label 6		The key 6",
			"0x00002466:Interactive label 7		The key 7",
			"0x00002467:Interactive label 8		The key 8",
			"0x00002468:Interactive label 9		The key 9",
			"0x00002469:Interactive label 10	The key 0",
			"0x000024C6:Interactive label Q		The key Q",
			"0x000024CC:Interactive label W		The key W",
			"0x000024BA:Interactive label E		The key E",
			"0x000024C7:Interactive label R		The key R",
			"0x000024C9:Interactive label T		The key T",
			"0x000024CE:Interactive label Y		The key Y",
			"0x000024CA:Interactive label U		The key U",
			"0x000024BE:Interactive label I		The key I",
			"0x000024C4:Interactive label O		The key O",
			"0x000024C5:Interactive label P		The key P",
			"0x000024B6:Interactive label A		The key A",
			"0x000024C8:Interactive label S		The key S",
			"0x000024B9:Interactive label D		The key D",
			"0x000024BB:Interactive label F		The key F",
			"0x000024BC:Interactive label G		The key G",
			"0x000024BD:Interactive label H		The key H",
			"0x000024BF:Interactive label I		The key J",
			"0x000024C0:Interactive label K		The key K",
			"0x000024C1:Interactive label L		The key L",
			"0x23CE000D:Enter",
			"0x21E50009:Tabulation",
			"0x000024CF:Interactive label Z		The key Z",
			"0x000024CD:Interactive label X		The key X",
			"0x000024B8:Interactive label C		The key C",
			"0x000024CB:Interactive label V		The key V",
			"0x000024B7:Interactive label B		The key B",
			"0x000024C3:Interactive label N		The key N",
			"0x000024C2:Interactive label M		The key M",
			"0x24090009:Tabulation",
			"0x003020E3:Number key 0"
		],	[
			"0x00002679:Special FX #7			---",
			"0x0000267A:Special FX +			---",
			"0x0000267D:Special FX ++			---",
			"0x00002227:Logical AND",
			"0x000021E1:Fade in FX - @\u2878\u283F\u2887	Increment the keyboard selector - @\u2328",
			"0x00002676:Special FX #4			---",
			"0x00002677:Special FX #5			---",
			"0x00002678:Special FX #6			---",
			"0x00002228:Logical OR",
			"0x000021E3:Fade out FX - @\u2878\u283F\u2887	Decrement the keyboard selector - @\u2328",
			"0x00002673:Special FX #1			---",
			"0x00002674:Special FX #2			---",
			"0x00002675:Special FX #3			---",
			"0x00002295:Logical XOR",
			"0x000033B3:Set the timer delaying interval(ms) - 1@ .. 10000@	Reset coefficients - 0@ / @	Change coefficients - \xBD@..9\xBC\xBD@",
			"0x00002672:Special FX #0			---",
			"0x0000267A:Special FX				---",
			"0x0000267B:Row repeating n-times - 1@ .. 999@",
			"0x00002328:Select keyboard - 0@ .. 9@		Set keyboards order - 11@ .. 999999999@",
			"0x00003390:Set the LEDs refreshing frequency(Hz) - 1@ .. 1000@",
			"0x00002637:Trigram FX #7 - Earth		---",
			"0x00000020:",
			"0x00000020:",
			"0x00002710:High bright",
			"0x00000020:",
			"0x00002634:Trigram FX #4 - Wind		---",
			"0x00002635:Trigram FX #5 - Water		---",
			"0x00002636:Trigram FX #6 - Mountain		---",
			"0x0000270F:Middle bright",
			"0x00000020:",
			"0x00002631:Trigram FX #1 - Lake		---",
			"0x00002632:Trigram FX #2 - Fire		---",
			"0x00002633:Trigram FX #3 - Thunder		---",
			"0x0000270E:Lower bright",
			"0x00000020:",
			"0x00002630:Trigram FX #0 - Heaven		---",
			"0x000025B2:Scroll up",
			"0x000025B6:Scroll right",
			"0x00002935:Go to next line in paragraph	Skip lines in paragraph - 1@ .. 999@",
			"0x00002397:Push history			--- comming soon",
			"0x00000020:",
			"0x000025C0:Scroll left",
			"0x000025BC:Scroll down",
			"0x00002934:Go to previous line of paragraph	Back up to lines in paragraph - 1@ .. 999@",
			"0x00002398:Pop history				--- comming soon"
		]
	];
	hTabs[0] = document.getElementById("Numbers");
	hTabs[1] = document.getElementById("Brailles");
	hTabs[2] = document.getElementById("Operators");
	hTabs[3] = document.getElementById("Effects");
	var	hTab, hRow, hCell, pattern, hMode;
	var	x, y, i, n, order, tmp;
	var	order = 34290810;
	//
	hTab = hTabs[(order - order % 10) / 10 % 10];
	for(y = -1; y < 8; ++ y) {
		hRow = hTab.insertRow(y + 1);
		for(x = -1; x < 8; ++ x) {
			tmp = x < 0 ? y < 0 ? [0x28C0, "Using dots-pattern"] : [0x2880 + y, "Left dots only"] : y < 0 ? [0x2840 + x * 8, "Right dots only"] : [0x2800 + x * 8 + y, "Paste this six dots"];
			hCell = hRow.insertCell(x + 1);
			hCell.className = "operator";
			hCell.width = "32px";
			hCell.title = tmp[1];
			hCell.innerHTML = "&#" + tmp[0] + ";";
			hCell.innerHTML = "<span style=position:absolute>&#" + tmp[0] + ";</span><span style=color:yellow>&#x283F;</span>";
			hCell.title = hCell.title.replace(/[\t]+/g, "\r\n").replace(/@/g, hCell.textContent);
			hCell.addEventListener("click", insertOperator);
		}
	}
	hTab.style.display = "none";
	hTab.addEventListener("mouseover", holdingTable);
	hTab.addEventListener("mouseout", hidingTable);
	do {
		order = (order - order % 100) / 100;
		iTabs = (order - order % 10) / 10 % 10;
		hTab = hTabs[iTabs];
		pattern = layouts[iTabs];
		if(iTabs > 0) {
			hTab.addEventListener("mouseover", holdingTable);
			hTab.addEventListener("mouseout", hidingTable);
		}
		for(y = 0; y < 9; ++ y) {
			hRow = hTab.insertRow(y);
			for(x = 0; x <= order % 10; ++ x) {
				tmp = pattern.shift().split(":");
				hCell = hRow.insertCell(x);
				hCell.className = "operator";
				hCell.width = "32px";
				hCell.title = tmp[1];
				tmp = parseInt(tmp[0]);
				if(tmp < 65535) {
					hCell.innerHTML = "&#" + tmp + ";";
					hCell.addEventListener("click", insertOperator);
				} else
				if((tmp >> 16) < 9) {
					hCell.className = "switch_" + (tmp >> 16);
					hCell.innerHTML = "&#" + (tmp & 65535) + ";";
					switch(tmp >> 16) {
					case 1:	hCell.addEventListener("click", function() {
						hTabs[iTabs].style.display = 'none'; iTabs = 1;
						hTabs[iTabs].style.display = 'block';		});
						break;
					case 2:	hCell.addEventListener("click", function() {
						hTabs[iTabs].style.display = 'none'; iTabs = 2;
						hTabs[iTabs].style.display = 'block';		});
						break;
					case 3:	hCell.addEventListener("click", function() {
						hTabs[iTabs].style.display = 'none'; iTabs = 3;
						hTabs[iTabs].style.display = 'block';		});
						break;
					}
				} else {
					hCell.innerHTML = "&#" + (tmp >> 16) + ";&#" + (tmp & 65535) + ";";
					hCell.addEventListener("click", insertOperator);
				}
				hCell.title = hCell.title.replace(/[\t]+/g, "\r\n").replace(/@/g, hCell.textContent);
			}
		}
		hTab.style.display = "none";
	} while(order >= 100);
	iTabs = 0;
	hTabs[iTabs].style.display = "block";
	LEDs.Scenario = {
		pSection	:null,
		pDots		:[],
		pRems		:[],
		iTags		:[],
		iKeys		:[],
		iReps		:-1,
		pReps		:null,
		nReps		:[],
		dReps		:[],
		iLoop		:-1,
		iRow		:-1,
		ptr		:null,
		iDelayPeriod	:-1,
		iDelayMultiplier:-1,
		iDelayDivider	:-1,
		iNumerator	:-1,
		iDenominator	:-1,
		iKeyboard	:-1,
		jSection	:-1
	};
	for(i = 0; i < 10; ++ i) {
		LEDs.Sections[i] = {
			pSection	:null,
			pDots		:[],
			pRems		:[],
			iTags		:[],
			iKeys		:[],
			iReps		:-1,
			pReps		:null,
			nReps		:[],
			dReps		:[],
			iLoop		:-1,
			iRow		:-1,
			ptr		:null,
			iDelayPeriod	:-1,
			iDelayMultiplier:-1,
			iDelayDivider	:-1,
			iNumerator	:-1,
			iDenominator	:-1,
			iKeyboard	:-1,
			jSection	:-1
		};
		LEDs.Measures[i] = {
			cmd		:"",
			ptr		:0,
			iRow		:0,
			iDelayMul	:1,
			iDelayDiv	:1,
			tmp	:{
				iNumerator	:-1,
				iDenominator	:-1
			},
			log	:{
				args: [],
				text: ""
			}
		};
	}
	hMode = document.getElementById("Mode");
	hMode.addEventListener("keydown",
		function(e) {
			var	i = -1;
			if(0x30 <= e.keyCode && e.keyCode <= 0x39)
				i = (e.keyCode - 0x30 + 9) % 10 + 1;
			else
			if(VK.NUMPAD0 <= e.keyCode && e.keyCode <= VK.NUMPAD9)
				i = (e.keyCode - VK.NUMPAD0 + 9) % 10 + 11;
			else
			if(0x41 <= e.keyCode && e.keyCode <= 0x5A)
				i = e.keyCode - 0x40 + 20;
			if(i > 0) {
				i = LEDs.Scenario.iKeys[i];
				if(i > 0) 
					LEDs.Scenario.iRow = i;
			}
		}
	);
	hMode.addEventListener("keyup",
		function(e) {
			e.target.value = "";
		}
	);
	ShowLEDs(LEDs);
	url = window.location.href.split("?");
	if(url.length > 1) {
		url.pop().split("&")
		.forEach(function(str) {
			str = str.split("=");
			switch(str[0]) {
			case "script":
				document.getElementById("Scenario").value = unescape(str[1].replace(/%25u/g, "%u"));
				break;
			}
			return true;
		});
		url = url.join("?");
	} else
		url = window.location.href;
}
</script>
</head>
<body onload='main()'>
<table>
<tr valign=top>
<td colspan=2><pre id=leds></pre></td></tr>
<tr><td>
<textarea id='Scenario' rows=25 cols=80>
Glazeur-scenario
&sect;1 &#x33B3;&#x21E5;	Paragraph #1
&#x21E5;	

&#x21E5;	Main paragraph
Hello world!
&#x21E5;	1000&#x33B3;100&#x3390;
&#x21E5;	1524&#x2328;1&#x2328;
&#x21E5;	&#x2399;&#x23F1;&#x239A;&#x23F1;</textarea></td>
<td valign='top'><table id='Brailles'></table>
<table id='Numbers'></table>
<table id='Operators'></table>
<table id='Effects'></table></td></tr></table>
<input id='Mode' size='80' onfocus='document.getElementById("Progress").href=url+"?script="+escape(document.getElementById("Scenario").value.split(/\r?\n/).join("\r\n")).replace(/%u/g, "%25u"); parse(LEDs, document.getElementById("Scenario").value)'
	placeholder='Change "Glazeur-scenario" mode - press 0-9 or A-Z keys' />
<a href='' id=Progress title='Click for share'>Share this scenario</a>
<p style=text-align:center><a href='http://github.com/Alikberov'>Visit me now</a><br />&copy;2017 Alikberov</p>
</body>
